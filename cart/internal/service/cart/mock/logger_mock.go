// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/xloroff/ozon-hw-go/cart/internal/pkg/logger.Logger -o logger_mock.go -n LoggerMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoggerMock implements logger.Logger
type LoggerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mLoggerMockClose

	funcDebug          func(ctx context.Context, m string)
	inspectFuncDebug   func(ctx context.Context, m string)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugf          func(ctx context.Context, m string, args ...any)
	inspectFuncDebugf   func(ctx context.Context, m string, args ...any)
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerMockDebugf

	funcError          func(ctx context.Context, m string)
	inspectFuncError   func(ctx context.Context, m string)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorf          func(ctx context.Context, m string, args ...any)
	inspectFuncErrorf   func(ctx context.Context, m string, args ...any)
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerMockErrorf

	funcFatal          func(ctx context.Context, m string)
	inspectFuncFatal   func(ctx context.Context, m string)
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mLoggerMockFatal

	funcFatalf          func(ctx context.Context, m string, args ...any)
	inspectFuncFatalf   func(ctx context.Context, m string, args ...any)
	afterFatalfCounter  uint64
	beforeFatalfCounter uint64
	FatalfMock          mLoggerMockFatalf

	funcInfo          func(ctx context.Context, m string)
	inspectFuncInfo   func(ctx context.Context, m string)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfof          func(ctx context.Context, m string, args ...any)
	inspectFuncInfof   func(ctx context.Context, m string, args ...any)
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerMockInfof

	funcPanic          func(ctx context.Context, m string)
	inspectFuncPanic   func(ctx context.Context, m string)
	afterPanicCounter  uint64
	beforePanicCounter uint64
	PanicMock          mLoggerMockPanic

	funcPanicf          func(ctx context.Context, m string, args ...any)
	inspectFuncPanicf   func(ctx context.Context, m string, args ...any)
	afterPanicfCounter  uint64
	beforePanicfCounter uint64
	PanicfMock          mLoggerMockPanicf

	funcWarn          func(ctx context.Context, m string)
	inspectFuncWarn   func(ctx context.Context, m string)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn

	funcWarnf          func(ctx context.Context, m string, args ...any)
	inspectFuncWarnf   func(ctx context.Context, m string, args ...any)
	afterWarnfCounter  uint64
	beforeWarnfCounter uint64
	WarnfMock          mLoggerMockWarnf
}

// NewLoggerMock returns a mock for logger.Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mLoggerMockClose{mock: m}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugfMock = mLoggerMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerMockDebugfParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorfMock = mLoggerMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerMockErrorfParams{}

	m.FatalMock = mLoggerMockFatal{mock: m}
	m.FatalMock.callArgs = []*LoggerMockFatalParams{}

	m.FatalfMock = mLoggerMockFatalf{mock: m}
	m.FatalfMock.callArgs = []*LoggerMockFatalfParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfofMock = mLoggerMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerMockInfofParams{}

	m.PanicMock = mLoggerMockPanic{mock: m}
	m.PanicMock.callArgs = []*LoggerMockPanicParams{}

	m.PanicfMock = mLoggerMockPanicf{mock: m}
	m.PanicfMock.callArgs = []*LoggerMockPanicfParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	m.WarnfMock = mLoggerMockWarnf{mock: m}
	m.WarnfMock.callArgs = []*LoggerMockWarnfParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerMockClose struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockCloseExpectation
	expectations       []*LoggerMockCloseExpectation

	expectedInvocations uint64
}

// LoggerMockCloseExpectation specifies expectation struct of the Logger.Close
type LoggerMockCloseExpectation struct {
	mock *LoggerMock

	results *LoggerMockCloseResults
	Counter uint64
}

// LoggerMockCloseResults contains results of the Logger.Close
type LoggerMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mLoggerMockClose) Optional() *mLoggerMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Logger.Close
func (mmClose *mLoggerMockClose) Expect() *mLoggerMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("LoggerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &LoggerMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Logger.Close
func (mmClose *mLoggerMockClose) Inspect(f func()) *mLoggerMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for LoggerMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Logger.Close
func (mmClose *mLoggerMockClose) Return(err error) *LoggerMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("LoggerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &LoggerMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &LoggerMockCloseResults{err}
	return mmClose.mock
}

// Set uses given function f to mock the Logger.Close method
func (mmClose *mLoggerMockClose) Set(f func() (err error)) *LoggerMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Logger.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Logger.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Times sets number of times Logger.Close should be invoked
func (mmClose *mLoggerMockClose) Times(n uint64) *mLoggerMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of LoggerMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	return mmClose
}

func (mmClose *mLoggerMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements logger.Logger
func (mmClose *LoggerMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the LoggerMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to LoggerMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished LoggerMock.Close invocations
func (mmClose *LoggerMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of LoggerMock.Close invocations
func (mmClose *LoggerMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *LoggerMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LoggerMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Close")
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Close but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), afterCloseCounter)
	}
}

type mLoggerMockDebug struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockDebugParams
	paramPtrs *LoggerMockDebugParamPtrs

	Counter uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	ctx context.Context
	m   string
}

// LoggerMockDebugParamPtrs contains pointers to parameters of the Logger.Debug
type LoggerMockDebugParamPtrs struct {
	ctx *context.Context
	m   *string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebug *mLoggerMockDebug) Optional() *mLoggerMockDebug {
	mmDebug.optional = true
	return mmDebug
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(ctx context.Context, m string) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.paramPtrs != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by ExpectParams functions")
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{ctx, m}
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectCtxParam1(ctx context.Context) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDebug
}

// ExpectMParam2 sets up expected param m for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectMParam2(m string) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.m = &m

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(ctx context.Context, m string)) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	return mmDebug.mock
}

// Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(ctx context.Context, m string)) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	return mmDebug.mock
}

// Times sets number of times Logger.Debug should be invoked
func (mmDebug *mLoggerMockDebug) Times(n uint64) *mLoggerMockDebug {
	if n == 0 {
		mmDebug.mock.t.Fatalf("Times of LoggerMock.Debug mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebug.expectedInvocations, n)
	return mmDebug
}

func (mmDebug *mLoggerMockDebug) invocationsDone() bool {
	if len(mmDebug.expectations) == 0 && mmDebug.defaultExpectation == nil && mmDebug.mock.funcDebug == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebug.mock.afterDebugCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebug.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debug implements logger.Logger
func (mmDebug *LoggerMock) Debug(ctx context.Context, m string) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(ctx, m)
	}

	mm_params := LoggerMockDebugParams{ctx, m}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, &mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_want_ptrs := mmDebug.DebugMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugParams{ctx, m}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(ctx, m)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v %v", ctx, m)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	if m.DebugMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugMock.invocationsDone()
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *e.params)
		}
	}

	afterDebugCounter := mm_atomic.LoadUint64(&m.afterDebugCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && afterDebugCounter < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debug")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && afterDebugCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Debug")
	}

	if !m.DebugMock.invocationsDone() && afterDebugCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debug but found %d calls",
			mm_atomic.LoadUint64(&m.DebugMock.expectedInvocations), afterDebugCounter)
	}
}

type mLoggerMockDebugf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugfExpectation
	expectations       []*LoggerMockDebugfExpectation

	callArgs []*LoggerMockDebugfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockDebugfExpectation specifies expectation struct of the Logger.Debugf
type LoggerMockDebugfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockDebugfParams
	paramPtrs *LoggerMockDebugfParamPtrs

	Counter uint64
}

// LoggerMockDebugfParams contains parameters of the Logger.Debugf
type LoggerMockDebugfParams struct {
	ctx  context.Context
	m    string
	args []any
}

// LoggerMockDebugfParamPtrs contains pointers to parameters of the Logger.Debugf
type LoggerMockDebugfParamPtrs struct {
	ctx  *context.Context
	m    *string
	args *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebugf *mLoggerMockDebugf) Optional() *mLoggerMockDebugf {
	mmDebugf.optional = true
	return mmDebugf
}

// Expect sets up expected params for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Expect(ctx context.Context, m string, args ...any) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.paramPtrs != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by ExpectParams functions")
	}

	mmDebugf.defaultExpectation.params = &LoggerMockDebugfParams{ctx, m, args}
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectCtxParam1(ctx context.Context) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDebugf
}

// ExpectMParam2 sets up expected param m for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectMParam2(m string) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.m = &m

	return mmDebugf
}

// ExpectArgsParam3 sets up expected param args for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectArgsParam3(args ...any) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.args = &args

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Inspect(f func(ctx context.Context, m string, args ...any)) *mLoggerMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Return() *LoggerMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{mock: mmDebugf.mock}
	}

	return mmDebugf.mock
}

// Set uses given function f to mock the Logger.Debugf method
func (mmDebugf *mLoggerMockDebugf) Set(f func(ctx context.Context, m string, args ...any)) *LoggerMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the Logger.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the Logger.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	return mmDebugf.mock
}

// Times sets number of times Logger.Debugf should be invoked
func (mmDebugf *mLoggerMockDebugf) Times(n uint64) *mLoggerMockDebugf {
	if n == 0 {
		mmDebugf.mock.t.Fatalf("Times of LoggerMock.Debugf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebugf.expectedInvocations, n)
	return mmDebugf
}

func (mmDebugf *mLoggerMockDebugf) invocationsDone() bool {
	if len(mmDebugf.expectations) == 0 && mmDebugf.defaultExpectation == nil && mmDebugf.mock.funcDebugf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebugf.mock.afterDebugfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebugf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debugf implements logger.Logger
func (mmDebugf *LoggerMock) Debugf(ctx context.Context, m string, args ...any) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(ctx, m, args...)
	}

	mm_params := LoggerMockDebugfParams{ctx, m, args}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, &mm_params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		mm_want := mmDebugf.DebugfMock.defaultExpectation.params
		mm_want_ptrs := mmDebugf.DebugfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugfParams{ctx, m, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(ctx, m, args...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerMock.Debugf. %v %v %v", ctx, m, args)

}

// DebugfAfterCounter returns a count of finished LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerMockDebugf) Calls() []*LoggerMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugfDone() bool {
	if m.DebugfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugfMock.invocationsDone()
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *e.params)
		}
	}

	afterDebugfCounter := mm_atomic.LoadUint64(&m.afterDebugfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && afterDebugfCounter < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debugf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && afterDebugfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Debugf")
	}

	if !m.DebugfMock.invocationsDone() && afterDebugfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debugf but found %d calls",
			mm_atomic.LoadUint64(&m.DebugfMock.expectedInvocations), afterDebugfCounter)
	}
}

type mLoggerMockError struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockErrorParams
	paramPtrs *LoggerMockErrorParamPtrs

	Counter uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	ctx context.Context
	m   string
}

// LoggerMockErrorParamPtrs contains pointers to parameters of the Logger.Error
type LoggerMockErrorParamPtrs struct {
	ctx *context.Context
	m   *string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmError *mLoggerMockError) Optional() *mLoggerMockError {
	mmError.optional = true
	return mmError
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(ctx context.Context, m string) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.paramPtrs != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by ExpectParams functions")
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{ctx, m}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Error
func (mmError *mLoggerMockError) ExpectCtxParam1(ctx context.Context) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.ctx = &ctx

	return mmError
}

// ExpectMParam2 sets up expected param m for Logger.Error
func (mmError *mLoggerMockError) ExpectMParam2(m string) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.m = &m

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(ctx context.Context, m string)) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

// Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(ctx context.Context, m string)) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Times sets number of times Logger.Error should be invoked
func (mmError *mLoggerMockError) Times(n uint64) *mLoggerMockError {
	if n == 0 {
		mmError.mock.t.Fatalf("Times of LoggerMock.Error mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmError.expectedInvocations, n)
	return mmError
}

func (mmError *mLoggerMockError) invocationsDone() bool {
	if len(mmError.expectations) == 0 && mmError.defaultExpectation == nil && mmError.mock.funcError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmError.mock.afterErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Error implements logger.Logger
func (mmError *LoggerMock) Error(ctx context.Context, m string) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(ctx, m)
	}

	mm_params := LoggerMockErrorParams{ctx, m}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_want_ptrs := mmError.ErrorMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorParams{ctx, m}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(ctx, m)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v %v", ctx, m)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	if m.ErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorMock.invocationsDone()
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *e.params)
		}
	}

	afterErrorCounter := mm_atomic.LoadUint64(&m.afterErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && afterErrorCounter < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Error")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && afterErrorCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Error")
	}

	if !m.ErrorMock.invocationsDone() && afterErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Error but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorMock.expectedInvocations), afterErrorCounter)
	}
}

type mLoggerMockErrorf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorfExpectation
	expectations       []*LoggerMockErrorfExpectation

	callArgs []*LoggerMockErrorfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockErrorfExpectation specifies expectation struct of the Logger.Errorf
type LoggerMockErrorfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockErrorfParams
	paramPtrs *LoggerMockErrorfParamPtrs

	Counter uint64
}

// LoggerMockErrorfParams contains parameters of the Logger.Errorf
type LoggerMockErrorfParams struct {
	ctx  context.Context
	m    string
	args []any
}

// LoggerMockErrorfParamPtrs contains pointers to parameters of the Logger.Errorf
type LoggerMockErrorfParamPtrs struct {
	ctx  *context.Context
	m    *string
	args *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErrorf *mLoggerMockErrorf) Optional() *mLoggerMockErrorf {
	mmErrorf.optional = true
	return mmErrorf
}

// Expect sets up expected params for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Expect(ctx context.Context, m string, args ...any) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.paramPtrs != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by ExpectParams functions")
	}

	mmErrorf.defaultExpectation.params = &LoggerMockErrorfParams{ctx, m, args}
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectCtxParam1(ctx context.Context) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.ctx = &ctx

	return mmErrorf
}

// ExpectMParam2 sets up expected param m for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectMParam2(m string) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.m = &m

	return mmErrorf
}

// ExpectArgsParam3 sets up expected param args for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectArgsParam3(args ...any) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.args = &args

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Inspect(f func(ctx context.Context, m string, args ...any)) *mLoggerMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Return() *LoggerMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{mock: mmErrorf.mock}
	}

	return mmErrorf.mock
}

// Set uses given function f to mock the Logger.Errorf method
func (mmErrorf *mLoggerMockErrorf) Set(f func(ctx context.Context, m string, args ...any)) *LoggerMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Logger.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Logger.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	return mmErrorf.mock
}

// Times sets number of times Logger.Errorf should be invoked
func (mmErrorf *mLoggerMockErrorf) Times(n uint64) *mLoggerMockErrorf {
	if n == 0 {
		mmErrorf.mock.t.Fatalf("Times of LoggerMock.Errorf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErrorf.expectedInvocations, n)
	return mmErrorf
}

func (mmErrorf *mLoggerMockErrorf) invocationsDone() bool {
	if len(mmErrorf.expectations) == 0 && mmErrorf.defaultExpectation == nil && mmErrorf.mock.funcErrorf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErrorf.mock.afterErrorfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErrorf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Errorf implements logger.Logger
func (mmErrorf *LoggerMock) Errorf(ctx context.Context, m string, args ...any) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(ctx, m, args...)
	}

	mm_params := LoggerMockErrorfParams{ctx, m, args}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, &mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_want_ptrs := mmErrorf.ErrorfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorfParams{ctx, m, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(ctx, m, args...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerMock.Errorf. %v %v %v", ctx, m, args)

}

// ErrorfAfterCounter returns a count of finished LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerMockErrorf) Calls() []*LoggerMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorfDone() bool {
	if m.ErrorfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorfMock.invocationsDone()
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *e.params)
		}
	}

	afterErrorfCounter := mm_atomic.LoadUint64(&m.afterErrorfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && afterErrorfCounter < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Errorf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && afterErrorfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Errorf")
	}

	if !m.ErrorfMock.invocationsDone() && afterErrorfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Errorf but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorfMock.expectedInvocations), afterErrorfCounter)
	}
}

type mLoggerMockFatal struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalExpectation
	expectations       []*LoggerMockFatalExpectation

	callArgs []*LoggerMockFatalParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockFatalExpectation specifies expectation struct of the Logger.Fatal
type LoggerMockFatalExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockFatalParams
	paramPtrs *LoggerMockFatalParamPtrs

	Counter uint64
}

// LoggerMockFatalParams contains parameters of the Logger.Fatal
type LoggerMockFatalParams struct {
	ctx context.Context
	m   string
}

// LoggerMockFatalParamPtrs contains pointers to parameters of the Logger.Fatal
type LoggerMockFatalParamPtrs struct {
	ctx *context.Context
	m   *string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatal *mLoggerMockFatal) Optional() *mLoggerMockFatal {
	mmFatal.optional = true
	return mmFatal
}

// Expect sets up expected params for Logger.Fatal
func (mmFatal *mLoggerMockFatal) Expect(ctx context.Context, m string) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.paramPtrs != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by ExpectParams functions")
	}

	mmFatal.defaultExpectation.params = &LoggerMockFatalParams{ctx, m}
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Fatal
func (mmFatal *mLoggerMockFatal) ExpectCtxParam1(ctx context.Context) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &LoggerMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.ctx = &ctx

	return mmFatal
}

// ExpectMParam2 sets up expected param m for Logger.Fatal
func (mmFatal *mLoggerMockFatal) ExpectMParam2(m string) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &LoggerMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.m = &m

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatal
func (mmFatal *mLoggerMockFatal) Inspect(f func(ctx context.Context, m string)) *mLoggerMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by Logger.Fatal
func (mmFatal *mLoggerMockFatal) Return() *LoggerMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{mock: mmFatal.mock}
	}

	return mmFatal.mock
}

// Set uses given function f to mock the Logger.Fatal method
func (mmFatal *mLoggerMockFatal) Set(f func(ctx context.Context, m string)) *LoggerMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the Logger.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the Logger.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	return mmFatal.mock
}

// Times sets number of times Logger.Fatal should be invoked
func (mmFatal *mLoggerMockFatal) Times(n uint64) *mLoggerMockFatal {
	if n == 0 {
		mmFatal.mock.t.Fatalf("Times of LoggerMock.Fatal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatal.expectedInvocations, n)
	return mmFatal
}

func (mmFatal *mLoggerMockFatal) invocationsDone() bool {
	if len(mmFatal.expectations) == 0 && mmFatal.defaultExpectation == nil && mmFatal.mock.funcFatal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatal.mock.afterFatalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatal implements logger.Logger
func (mmFatal *LoggerMock) Fatal(ctx context.Context, m string) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(ctx, m)
	}

	mm_params := LoggerMockFatalParams{ctx, m}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, &mm_params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		mm_want := mmFatal.FatalMock.defaultExpectation.params
		mm_want_ptrs := mmFatal.FatalMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockFatalParams{ctx, m}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(ctx, m)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to LoggerMock.Fatal. %v %v", ctx, m)

}

// FatalAfterCounter returns a count of finished LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mLoggerMockFatal) Calls() []*LoggerMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*LoggerMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalDone() bool {
	if m.FatalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalMock.invocationsDone()
}

// MinimockFatalInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatal with params: %#v", *e.params)
		}
	}

	afterFatalCounter := mm_atomic.LoadUint64(&m.afterFatalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && afterFatalCounter < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Fatal")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatal with params: %#v", *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && afterFatalCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Fatal")
	}

	if !m.FatalMock.invocationsDone() && afterFatalCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Fatal but found %d calls",
			mm_atomic.LoadUint64(&m.FatalMock.expectedInvocations), afterFatalCounter)
	}
}

type mLoggerMockFatalf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalfExpectation
	expectations       []*LoggerMockFatalfExpectation

	callArgs []*LoggerMockFatalfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockFatalfExpectation specifies expectation struct of the Logger.Fatalf
type LoggerMockFatalfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockFatalfParams
	paramPtrs *LoggerMockFatalfParamPtrs

	Counter uint64
}

// LoggerMockFatalfParams contains parameters of the Logger.Fatalf
type LoggerMockFatalfParams struct {
	ctx  context.Context
	m    string
	args []any
}

// LoggerMockFatalfParamPtrs contains pointers to parameters of the Logger.Fatalf
type LoggerMockFatalfParamPtrs struct {
	ctx  *context.Context
	m    *string
	args *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatalf *mLoggerMockFatalf) Optional() *mLoggerMockFatalf {
	mmFatalf.optional = true
	return mmFatalf
}

// Expect sets up expected params for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Expect(ctx context.Context, m string, args ...any) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.paramPtrs != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by ExpectParams functions")
	}

	mmFatalf.defaultExpectation.params = &LoggerMockFatalfParams{ctx, m, args}
	for _, e := range mmFatalf.expectations {
		if minimock.Equal(e.params, mmFatalf.defaultExpectation.params) {
			mmFatalf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatalf.defaultExpectation.params)
		}
	}

	return mmFatalf
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) ExpectCtxParam1(ctx context.Context) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &LoggerMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.ctx = &ctx

	return mmFatalf
}

// ExpectMParam2 sets up expected param m for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) ExpectMParam2(m string) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &LoggerMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.m = &m

	return mmFatalf
}

// ExpectArgsParam3 sets up expected param args for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) ExpectArgsParam3(args ...any) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &LoggerMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.args = &args

	return mmFatalf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Inspect(f func(ctx context.Context, m string, args ...any)) *mLoggerMockFatalf {
	if mmFatalf.mock.inspectFuncFatalf != nil {
		mmFatalf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatalf")
	}

	mmFatalf.mock.inspectFuncFatalf = f

	return mmFatalf
}

// Return sets up results that will be returned by Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Return() *LoggerMock {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{mock: mmFatalf.mock}
	}

	return mmFatalf.mock
}

// Set uses given function f to mock the Logger.Fatalf method
func (mmFatalf *mLoggerMockFatalf) Set(f func(ctx context.Context, m string, args ...any)) *LoggerMock {
	if mmFatalf.defaultExpectation != nil {
		mmFatalf.mock.t.Fatalf("Default expectation is already set for the Logger.Fatalf method")
	}

	if len(mmFatalf.expectations) > 0 {
		mmFatalf.mock.t.Fatalf("Some expectations are already set for the Logger.Fatalf method")
	}

	mmFatalf.mock.funcFatalf = f
	return mmFatalf.mock
}

// Times sets number of times Logger.Fatalf should be invoked
func (mmFatalf *mLoggerMockFatalf) Times(n uint64) *mLoggerMockFatalf {
	if n == 0 {
		mmFatalf.mock.t.Fatalf("Times of LoggerMock.Fatalf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatalf.expectedInvocations, n)
	return mmFatalf
}

func (mmFatalf *mLoggerMockFatalf) invocationsDone() bool {
	if len(mmFatalf.expectations) == 0 && mmFatalf.defaultExpectation == nil && mmFatalf.mock.funcFatalf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatalf.mock.afterFatalfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatalf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatalf implements logger.Logger
func (mmFatalf *LoggerMock) Fatalf(ctx context.Context, m string, args ...any) {
	mm_atomic.AddUint64(&mmFatalf.beforeFatalfCounter, 1)
	defer mm_atomic.AddUint64(&mmFatalf.afterFatalfCounter, 1)

	if mmFatalf.inspectFuncFatalf != nil {
		mmFatalf.inspectFuncFatalf(ctx, m, args...)
	}

	mm_params := LoggerMockFatalfParams{ctx, m, args}

	// Record call args
	mmFatalf.FatalfMock.mutex.Lock()
	mmFatalf.FatalfMock.callArgs = append(mmFatalf.FatalfMock.callArgs, &mm_params)
	mmFatalf.FatalfMock.mutex.Unlock()

	for _, e := range mmFatalf.FatalfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatalf.FatalfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatalf.FatalfMock.defaultExpectation.Counter, 1)
		mm_want := mmFatalf.FatalfMock.defaultExpectation.params
		mm_want_ptrs := mmFatalf.FatalfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockFatalfParams{ctx, m, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatalf.funcFatalf != nil {
		mmFatalf.funcFatalf(ctx, m, args...)
		return
	}
	mmFatalf.t.Fatalf("Unexpected call to LoggerMock.Fatalf. %v %v %v", ctx, m, args)

}

// FatalfAfterCounter returns a count of finished LoggerMock.Fatalf invocations
func (mmFatalf *LoggerMock) FatalfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.afterFatalfCounter)
}

// FatalfBeforeCounter returns a count of LoggerMock.Fatalf invocations
func (mmFatalf *LoggerMock) FatalfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.beforeFatalfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatalf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatalf *mLoggerMockFatalf) Calls() []*LoggerMockFatalfParams {
	mmFatalf.mutex.RLock()

	argCopy := make([]*LoggerMockFatalfParams, len(mmFatalf.callArgs))
	copy(argCopy, mmFatalf.callArgs)

	mmFatalf.mutex.RUnlock()

	return argCopy
}

// MinimockFatalfDone returns true if the count of the Fatalf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalfDone() bool {
	if m.FatalfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalfMock.invocationsDone()
}

// MinimockFatalfInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalfInspect() {
	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatalf with params: %#v", *e.params)
		}
	}

	afterFatalfCounter := mm_atomic.LoadUint64(&m.afterFatalfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalfMock.defaultExpectation != nil && afterFatalfCounter < 1 {
		if m.FatalfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Fatalf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatalf with params: %#v", *m.FatalfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatalf != nil && afterFatalfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Fatalf")
	}

	if !m.FatalfMock.invocationsDone() && afterFatalfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Fatalf but found %d calls",
			mm_atomic.LoadUint64(&m.FatalfMock.expectedInvocations), afterFatalfCounter)
	}
}

type mLoggerMockInfo struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockInfoParams
	paramPtrs *LoggerMockInfoParamPtrs

	Counter uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	ctx context.Context
	m   string
}

// LoggerMockInfoParamPtrs contains pointers to parameters of the Logger.Info
type LoggerMockInfoParamPtrs struct {
	ctx *context.Context
	m   *string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfo *mLoggerMockInfo) Optional() *mLoggerMockInfo {
	mmInfo.optional = true
	return mmInfo
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(ctx context.Context, m string) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.paramPtrs != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by ExpectParams functions")
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{ctx, m}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectCtxParam1(ctx context.Context) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.ctx = &ctx

	return mmInfo
}

// ExpectMParam2 sets up expected param m for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectMParam2(m string) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.m = &m

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(ctx context.Context, m string)) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	return mmInfo.mock
}

// Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(ctx context.Context, m string)) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// Times sets number of times Logger.Info should be invoked
func (mmInfo *mLoggerMockInfo) Times(n uint64) *mLoggerMockInfo {
	if n == 0 {
		mmInfo.mock.t.Fatalf("Times of LoggerMock.Info mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfo.expectedInvocations, n)
	return mmInfo
}

func (mmInfo *mLoggerMockInfo) invocationsDone() bool {
	if len(mmInfo.expectations) == 0 && mmInfo.defaultExpectation == nil && mmInfo.mock.funcInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfo.mock.afterInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Info implements logger.Logger
func (mmInfo *LoggerMock) Info(ctx context.Context, m string) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(ctx, m)
	}

	mm_params := LoggerMockInfoParams{ctx, m}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, &mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_want_ptrs := mmInfo.InfoMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfoParams{ctx, m}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(ctx, m)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v %v", ctx, m)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	if m.InfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfoMock.invocationsDone()
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *e.params)
		}
	}

	afterInfoCounter := mm_atomic.LoadUint64(&m.afterInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && afterInfoCounter < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Info")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && afterInfoCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Info")
	}

	if !m.InfoMock.invocationsDone() && afterInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Info but found %d calls",
			mm_atomic.LoadUint64(&m.InfoMock.expectedInvocations), afterInfoCounter)
	}
}

type mLoggerMockInfof struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfofExpectation
	expectations       []*LoggerMockInfofExpectation

	callArgs []*LoggerMockInfofParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockInfofExpectation specifies expectation struct of the Logger.Infof
type LoggerMockInfofExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockInfofParams
	paramPtrs *LoggerMockInfofParamPtrs

	Counter uint64
}

// LoggerMockInfofParams contains parameters of the Logger.Infof
type LoggerMockInfofParams struct {
	ctx  context.Context
	m    string
	args []any
}

// LoggerMockInfofParamPtrs contains pointers to parameters of the Logger.Infof
type LoggerMockInfofParamPtrs struct {
	ctx  *context.Context
	m    *string
	args *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfof *mLoggerMockInfof) Optional() *mLoggerMockInfof {
	mmInfof.optional = true
	return mmInfof
}

// Expect sets up expected params for Logger.Infof
func (mmInfof *mLoggerMockInfof) Expect(ctx context.Context, m string, args ...any) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.paramPtrs != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by ExpectParams functions")
	}

	mmInfof.defaultExpectation.params = &LoggerMockInfofParams{ctx, m, args}
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectCtxParam1(ctx context.Context) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.ctx = &ctx

	return mmInfof
}

// ExpectMParam2 sets up expected param m for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectMParam2(m string) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.m = &m

	return mmInfof
}

// ExpectArgsParam3 sets up expected param args for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectArgsParam3(args ...any) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.args = &args

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the Logger.Infof
func (mmInfof *mLoggerMockInfof) Inspect(f func(ctx context.Context, m string, args ...any)) *mLoggerMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by Logger.Infof
func (mmInfof *mLoggerMockInfof) Return() *LoggerMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{mock: mmInfof.mock}
	}

	return mmInfof.mock
}

// Set uses given function f to mock the Logger.Infof method
func (mmInfof *mLoggerMockInfof) Set(f func(ctx context.Context, m string, args ...any)) *LoggerMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the Logger.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the Logger.Infof method")
	}

	mmInfof.mock.funcInfof = f
	return mmInfof.mock
}

// Times sets number of times Logger.Infof should be invoked
func (mmInfof *mLoggerMockInfof) Times(n uint64) *mLoggerMockInfof {
	if n == 0 {
		mmInfof.mock.t.Fatalf("Times of LoggerMock.Infof mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfof.expectedInvocations, n)
	return mmInfof
}

func (mmInfof *mLoggerMockInfof) invocationsDone() bool {
	if len(mmInfof.expectations) == 0 && mmInfof.defaultExpectation == nil && mmInfof.mock.funcInfof == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfof.mock.afterInfofCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfof.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Infof implements logger.Logger
func (mmInfof *LoggerMock) Infof(ctx context.Context, m string, args ...any) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(ctx, m, args...)
	}

	mm_params := LoggerMockInfofParams{ctx, m, args}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, &mm_params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		mm_want := mmInfof.InfofMock.defaultExpectation.params
		mm_want_ptrs := mmInfof.InfofMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfofParams{ctx, m, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(ctx, m, args...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerMock.Infof. %v %v %v", ctx, m, args)

}

// InfofAfterCounter returns a count of finished LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerMockInfof) Calls() []*LoggerMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfofDone() bool {
	if m.InfofMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfofMock.invocationsDone()
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *e.params)
		}
	}

	afterInfofCounter := mm_atomic.LoadUint64(&m.afterInfofCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && afterInfofCounter < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Infof")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && afterInfofCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Infof")
	}

	if !m.InfofMock.invocationsDone() && afterInfofCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Infof but found %d calls",
			mm_atomic.LoadUint64(&m.InfofMock.expectedInvocations), afterInfofCounter)
	}
}

type mLoggerMockPanic struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockPanicExpectation
	expectations       []*LoggerMockPanicExpectation

	callArgs []*LoggerMockPanicParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockPanicExpectation specifies expectation struct of the Logger.Panic
type LoggerMockPanicExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockPanicParams
	paramPtrs *LoggerMockPanicParamPtrs

	Counter uint64
}

// LoggerMockPanicParams contains parameters of the Logger.Panic
type LoggerMockPanicParams struct {
	ctx context.Context
	m   string
}

// LoggerMockPanicParamPtrs contains pointers to parameters of the Logger.Panic
type LoggerMockPanicParamPtrs struct {
	ctx *context.Context
	m   *string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPanic *mLoggerMockPanic) Optional() *mLoggerMockPanic {
	mmPanic.optional = true
	return mmPanic
}

// Expect sets up expected params for Logger.Panic
func (mmPanic *mLoggerMockPanic) Expect(ctx context.Context, m string) *mLoggerMockPanic {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &LoggerMockPanicExpectation{}
	}

	if mmPanic.defaultExpectation.paramPtrs != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by ExpectParams functions")
	}

	mmPanic.defaultExpectation.params = &LoggerMockPanicParams{ctx, m}
	for _, e := range mmPanic.expectations {
		if minimock.Equal(e.params, mmPanic.defaultExpectation.params) {
			mmPanic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPanic.defaultExpectation.params)
		}
	}

	return mmPanic
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Panic
func (mmPanic *mLoggerMockPanic) ExpectCtxParam1(ctx context.Context) *mLoggerMockPanic {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &LoggerMockPanicExpectation{}
	}

	if mmPanic.defaultExpectation.params != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Expect")
	}

	if mmPanic.defaultExpectation.paramPtrs == nil {
		mmPanic.defaultExpectation.paramPtrs = &LoggerMockPanicParamPtrs{}
	}
	mmPanic.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPanic
}

// ExpectMParam2 sets up expected param m for Logger.Panic
func (mmPanic *mLoggerMockPanic) ExpectMParam2(m string) *mLoggerMockPanic {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &LoggerMockPanicExpectation{}
	}

	if mmPanic.defaultExpectation.params != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Expect")
	}

	if mmPanic.defaultExpectation.paramPtrs == nil {
		mmPanic.defaultExpectation.paramPtrs = &LoggerMockPanicParamPtrs{}
	}
	mmPanic.defaultExpectation.paramPtrs.m = &m

	return mmPanic
}

// Inspect accepts an inspector function that has same arguments as the Logger.Panic
func (mmPanic *mLoggerMockPanic) Inspect(f func(ctx context.Context, m string)) *mLoggerMockPanic {
	if mmPanic.mock.inspectFuncPanic != nil {
		mmPanic.mock.t.Fatalf("Inspect function is already set for LoggerMock.Panic")
	}

	mmPanic.mock.inspectFuncPanic = f

	return mmPanic
}

// Return sets up results that will be returned by Logger.Panic
func (mmPanic *mLoggerMockPanic) Return() *LoggerMock {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &LoggerMockPanicExpectation{mock: mmPanic.mock}
	}

	return mmPanic.mock
}

// Set uses given function f to mock the Logger.Panic method
func (mmPanic *mLoggerMockPanic) Set(f func(ctx context.Context, m string)) *LoggerMock {
	if mmPanic.defaultExpectation != nil {
		mmPanic.mock.t.Fatalf("Default expectation is already set for the Logger.Panic method")
	}

	if len(mmPanic.expectations) > 0 {
		mmPanic.mock.t.Fatalf("Some expectations are already set for the Logger.Panic method")
	}

	mmPanic.mock.funcPanic = f
	return mmPanic.mock
}

// Times sets number of times Logger.Panic should be invoked
func (mmPanic *mLoggerMockPanic) Times(n uint64) *mLoggerMockPanic {
	if n == 0 {
		mmPanic.mock.t.Fatalf("Times of LoggerMock.Panic mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPanic.expectedInvocations, n)
	return mmPanic
}

func (mmPanic *mLoggerMockPanic) invocationsDone() bool {
	if len(mmPanic.expectations) == 0 && mmPanic.defaultExpectation == nil && mmPanic.mock.funcPanic == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPanic.mock.afterPanicCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPanic.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Panic implements logger.Logger
func (mmPanic *LoggerMock) Panic(ctx context.Context, m string) {
	mm_atomic.AddUint64(&mmPanic.beforePanicCounter, 1)
	defer mm_atomic.AddUint64(&mmPanic.afterPanicCounter, 1)

	if mmPanic.inspectFuncPanic != nil {
		mmPanic.inspectFuncPanic(ctx, m)
	}

	mm_params := LoggerMockPanicParams{ctx, m}

	// Record call args
	mmPanic.PanicMock.mutex.Lock()
	mmPanic.PanicMock.callArgs = append(mmPanic.PanicMock.callArgs, &mm_params)
	mmPanic.PanicMock.mutex.Unlock()

	for _, e := range mmPanic.PanicMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPanic.PanicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPanic.PanicMock.defaultExpectation.Counter, 1)
		mm_want := mmPanic.PanicMock.defaultExpectation.params
		mm_want_ptrs := mmPanic.PanicMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockPanicParams{ctx, m}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPanic.t.Errorf("LoggerMock.Panic got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmPanic.t.Errorf("LoggerMock.Panic got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPanic.t.Errorf("LoggerMock.Panic got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPanic.funcPanic != nil {
		mmPanic.funcPanic(ctx, m)
		return
	}
	mmPanic.t.Fatalf("Unexpected call to LoggerMock.Panic. %v %v", ctx, m)

}

// PanicAfterCounter returns a count of finished LoggerMock.Panic invocations
func (mmPanic *LoggerMock) PanicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanic.afterPanicCounter)
}

// PanicBeforeCounter returns a count of LoggerMock.Panic invocations
func (mmPanic *LoggerMock) PanicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanic.beforePanicCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Panic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPanic *mLoggerMockPanic) Calls() []*LoggerMockPanicParams {
	mmPanic.mutex.RLock()

	argCopy := make([]*LoggerMockPanicParams, len(mmPanic.callArgs))
	copy(argCopy, mmPanic.callArgs)

	mmPanic.mutex.RUnlock()

	return argCopy
}

// MinimockPanicDone returns true if the count of the Panic invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPanicDone() bool {
	if m.PanicMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PanicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PanicMock.invocationsDone()
}

// MinimockPanicInspect logs each unmet expectation
func (m *LoggerMock) MinimockPanicInspect() {
	for _, e := range m.PanicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Panic with params: %#v", *e.params)
		}
	}

	afterPanicCounter := mm_atomic.LoadUint64(&m.afterPanicCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PanicMock.defaultExpectation != nil && afterPanicCounter < 1 {
		if m.PanicMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Panic")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Panic with params: %#v", *m.PanicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanic != nil && afterPanicCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Panic")
	}

	if !m.PanicMock.invocationsDone() && afterPanicCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Panic but found %d calls",
			mm_atomic.LoadUint64(&m.PanicMock.expectedInvocations), afterPanicCounter)
	}
}

type mLoggerMockPanicf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockPanicfExpectation
	expectations       []*LoggerMockPanicfExpectation

	callArgs []*LoggerMockPanicfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockPanicfExpectation specifies expectation struct of the Logger.Panicf
type LoggerMockPanicfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockPanicfParams
	paramPtrs *LoggerMockPanicfParamPtrs

	Counter uint64
}

// LoggerMockPanicfParams contains parameters of the Logger.Panicf
type LoggerMockPanicfParams struct {
	ctx  context.Context
	m    string
	args []any
}

// LoggerMockPanicfParamPtrs contains pointers to parameters of the Logger.Panicf
type LoggerMockPanicfParamPtrs struct {
	ctx  *context.Context
	m    *string
	args *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPanicf *mLoggerMockPanicf) Optional() *mLoggerMockPanicf {
	mmPanicf.optional = true
	return mmPanicf
}

// Expect sets up expected params for Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Expect(ctx context.Context, m string, args ...any) *mLoggerMockPanicf {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{}
	}

	if mmPanicf.defaultExpectation.paramPtrs != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by ExpectParams functions")
	}

	mmPanicf.defaultExpectation.params = &LoggerMockPanicfParams{ctx, m, args}
	for _, e := range mmPanicf.expectations {
		if minimock.Equal(e.params, mmPanicf.defaultExpectation.params) {
			mmPanicf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPanicf.defaultExpectation.params)
		}
	}

	return mmPanicf
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) ExpectCtxParam1(ctx context.Context) *mLoggerMockPanicf {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{}
	}

	if mmPanicf.defaultExpectation.params != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Expect")
	}

	if mmPanicf.defaultExpectation.paramPtrs == nil {
		mmPanicf.defaultExpectation.paramPtrs = &LoggerMockPanicfParamPtrs{}
	}
	mmPanicf.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPanicf
}

// ExpectMParam2 sets up expected param m for Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) ExpectMParam2(m string) *mLoggerMockPanicf {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{}
	}

	if mmPanicf.defaultExpectation.params != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Expect")
	}

	if mmPanicf.defaultExpectation.paramPtrs == nil {
		mmPanicf.defaultExpectation.paramPtrs = &LoggerMockPanicfParamPtrs{}
	}
	mmPanicf.defaultExpectation.paramPtrs.m = &m

	return mmPanicf
}

// ExpectArgsParam3 sets up expected param args for Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) ExpectArgsParam3(args ...any) *mLoggerMockPanicf {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{}
	}

	if mmPanicf.defaultExpectation.params != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Expect")
	}

	if mmPanicf.defaultExpectation.paramPtrs == nil {
		mmPanicf.defaultExpectation.paramPtrs = &LoggerMockPanicfParamPtrs{}
	}
	mmPanicf.defaultExpectation.paramPtrs.args = &args

	return mmPanicf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Inspect(f func(ctx context.Context, m string, args ...any)) *mLoggerMockPanicf {
	if mmPanicf.mock.inspectFuncPanicf != nil {
		mmPanicf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Panicf")
	}

	mmPanicf.mock.inspectFuncPanicf = f

	return mmPanicf
}

// Return sets up results that will be returned by Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Return() *LoggerMock {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{mock: mmPanicf.mock}
	}

	return mmPanicf.mock
}

// Set uses given function f to mock the Logger.Panicf method
func (mmPanicf *mLoggerMockPanicf) Set(f func(ctx context.Context, m string, args ...any)) *LoggerMock {
	if mmPanicf.defaultExpectation != nil {
		mmPanicf.mock.t.Fatalf("Default expectation is already set for the Logger.Panicf method")
	}

	if len(mmPanicf.expectations) > 0 {
		mmPanicf.mock.t.Fatalf("Some expectations are already set for the Logger.Panicf method")
	}

	mmPanicf.mock.funcPanicf = f
	return mmPanicf.mock
}

// Times sets number of times Logger.Panicf should be invoked
func (mmPanicf *mLoggerMockPanicf) Times(n uint64) *mLoggerMockPanicf {
	if n == 0 {
		mmPanicf.mock.t.Fatalf("Times of LoggerMock.Panicf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPanicf.expectedInvocations, n)
	return mmPanicf
}

func (mmPanicf *mLoggerMockPanicf) invocationsDone() bool {
	if len(mmPanicf.expectations) == 0 && mmPanicf.defaultExpectation == nil && mmPanicf.mock.funcPanicf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPanicf.mock.afterPanicfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPanicf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Panicf implements logger.Logger
func (mmPanicf *LoggerMock) Panicf(ctx context.Context, m string, args ...any) {
	mm_atomic.AddUint64(&mmPanicf.beforePanicfCounter, 1)
	defer mm_atomic.AddUint64(&mmPanicf.afterPanicfCounter, 1)

	if mmPanicf.inspectFuncPanicf != nil {
		mmPanicf.inspectFuncPanicf(ctx, m, args...)
	}

	mm_params := LoggerMockPanicfParams{ctx, m, args}

	// Record call args
	mmPanicf.PanicfMock.mutex.Lock()
	mmPanicf.PanicfMock.callArgs = append(mmPanicf.PanicfMock.callArgs, &mm_params)
	mmPanicf.PanicfMock.mutex.Unlock()

	for _, e := range mmPanicf.PanicfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPanicf.PanicfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPanicf.PanicfMock.defaultExpectation.Counter, 1)
		mm_want := mmPanicf.PanicfMock.defaultExpectation.params
		mm_want_ptrs := mmPanicf.PanicfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockPanicfParams{ctx, m, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPanicf.t.Errorf("LoggerMock.Panicf got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmPanicf.t.Errorf("LoggerMock.Panicf got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmPanicf.t.Errorf("LoggerMock.Panicf got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPanicf.t.Errorf("LoggerMock.Panicf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPanicf.funcPanicf != nil {
		mmPanicf.funcPanicf(ctx, m, args...)
		return
	}
	mmPanicf.t.Fatalf("Unexpected call to LoggerMock.Panicf. %v %v %v", ctx, m, args)

}

// PanicfAfterCounter returns a count of finished LoggerMock.Panicf invocations
func (mmPanicf *LoggerMock) PanicfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanicf.afterPanicfCounter)
}

// PanicfBeforeCounter returns a count of LoggerMock.Panicf invocations
func (mmPanicf *LoggerMock) PanicfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanicf.beforePanicfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Panicf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPanicf *mLoggerMockPanicf) Calls() []*LoggerMockPanicfParams {
	mmPanicf.mutex.RLock()

	argCopy := make([]*LoggerMockPanicfParams, len(mmPanicf.callArgs))
	copy(argCopy, mmPanicf.callArgs)

	mmPanicf.mutex.RUnlock()

	return argCopy
}

// MinimockPanicfDone returns true if the count of the Panicf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPanicfDone() bool {
	if m.PanicfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PanicfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PanicfMock.invocationsDone()
}

// MinimockPanicfInspect logs each unmet expectation
func (m *LoggerMock) MinimockPanicfInspect() {
	for _, e := range m.PanicfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Panicf with params: %#v", *e.params)
		}
	}

	afterPanicfCounter := mm_atomic.LoadUint64(&m.afterPanicfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PanicfMock.defaultExpectation != nil && afterPanicfCounter < 1 {
		if m.PanicfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Panicf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Panicf with params: %#v", *m.PanicfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanicf != nil && afterPanicfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Panicf")
	}

	if !m.PanicfMock.invocationsDone() && afterPanicfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Panicf but found %d calls",
			mm_atomic.LoadUint64(&m.PanicfMock.expectedInvocations), afterPanicfCounter)
	}
}

type mLoggerMockWarn struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockWarnParams
	paramPtrs *LoggerMockWarnParamPtrs

	Counter uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	ctx context.Context
	m   string
}

// LoggerMockWarnParamPtrs contains pointers to parameters of the Logger.Warn
type LoggerMockWarnParamPtrs struct {
	ctx *context.Context
	m   *string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarn *mLoggerMockWarn) Optional() *mLoggerMockWarn {
	mmWarn.optional = true
	return mmWarn
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(ctx context.Context, m string) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.paramPtrs != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by ExpectParams functions")
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{ctx, m}
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectCtxParam1(ctx context.Context) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.ctx = &ctx

	return mmWarn
}

// ExpectMParam2 sets up expected param m for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectMParam2(m string) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.m = &m

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(ctx context.Context, m string)) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	return mmWarn.mock
}

// Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(ctx context.Context, m string)) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	return mmWarn.mock
}

// Times sets number of times Logger.Warn should be invoked
func (mmWarn *mLoggerMockWarn) Times(n uint64) *mLoggerMockWarn {
	if n == 0 {
		mmWarn.mock.t.Fatalf("Times of LoggerMock.Warn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarn.expectedInvocations, n)
	return mmWarn
}

func (mmWarn *mLoggerMockWarn) invocationsDone() bool {
	if len(mmWarn.expectations) == 0 && mmWarn.defaultExpectation == nil && mmWarn.mock.funcWarn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarn.mock.afterWarnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warn implements logger.Logger
func (mmWarn *LoggerMock) Warn(ctx context.Context, m string) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(ctx, m)
	}

	mm_params := LoggerMockWarnParams{ctx, m}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, &mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_want_ptrs := mmWarn.WarnMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnParams{ctx, m}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(ctx, m)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v %v", ctx, m)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	if m.WarnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnMock.invocationsDone()
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *e.params)
		}
	}

	afterWarnCounter := mm_atomic.LoadUint64(&m.afterWarnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && afterWarnCounter < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warn")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && afterWarnCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Warn")
	}

	if !m.WarnMock.invocationsDone() && afterWarnCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warn but found %d calls",
			mm_atomic.LoadUint64(&m.WarnMock.expectedInvocations), afterWarnCounter)
	}
}

type mLoggerMockWarnf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnfExpectation
	expectations       []*LoggerMockWarnfExpectation

	callArgs []*LoggerMockWarnfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockWarnfExpectation specifies expectation struct of the Logger.Warnf
type LoggerMockWarnfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockWarnfParams
	paramPtrs *LoggerMockWarnfParamPtrs

	Counter uint64
}

// LoggerMockWarnfParams contains parameters of the Logger.Warnf
type LoggerMockWarnfParams struct {
	ctx  context.Context
	m    string
	args []any
}

// LoggerMockWarnfParamPtrs contains pointers to parameters of the Logger.Warnf
type LoggerMockWarnfParamPtrs struct {
	ctx  *context.Context
	m    *string
	args *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarnf *mLoggerMockWarnf) Optional() *mLoggerMockWarnf {
	mmWarnf.optional = true
	return mmWarnf
}

// Expect sets up expected params for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Expect(ctx context.Context, m string, args ...any) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.paramPtrs != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by ExpectParams functions")
	}

	mmWarnf.defaultExpectation.params = &LoggerMockWarnfParams{ctx, m, args}
	for _, e := range mmWarnf.expectations {
		if minimock.Equal(e.params, mmWarnf.defaultExpectation.params) {
			mmWarnf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnf.defaultExpectation.params)
		}
	}

	return mmWarnf
}

// ExpectCtxParam1 sets up expected param ctx for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectCtxParam1(ctx context.Context) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.ctx = &ctx

	return mmWarnf
}

// ExpectMParam2 sets up expected param m for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectMParam2(m string) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.m = &m

	return mmWarnf
}

// ExpectArgsParam3 sets up expected param args for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectArgsParam3(args ...any) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.args = &args

	return mmWarnf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Inspect(f func(ctx context.Context, m string, args ...any)) *mLoggerMockWarnf {
	if mmWarnf.mock.inspectFuncWarnf != nil {
		mmWarnf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warnf")
	}

	mmWarnf.mock.inspectFuncWarnf = f

	return mmWarnf
}

// Return sets up results that will be returned by Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Return() *LoggerMock {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{mock: mmWarnf.mock}
	}

	return mmWarnf.mock
}

// Set uses given function f to mock the Logger.Warnf method
func (mmWarnf *mLoggerMockWarnf) Set(f func(ctx context.Context, m string, args ...any)) *LoggerMock {
	if mmWarnf.defaultExpectation != nil {
		mmWarnf.mock.t.Fatalf("Default expectation is already set for the Logger.Warnf method")
	}

	if len(mmWarnf.expectations) > 0 {
		mmWarnf.mock.t.Fatalf("Some expectations are already set for the Logger.Warnf method")
	}

	mmWarnf.mock.funcWarnf = f
	return mmWarnf.mock
}

// Times sets number of times Logger.Warnf should be invoked
func (mmWarnf *mLoggerMockWarnf) Times(n uint64) *mLoggerMockWarnf {
	if n == 0 {
		mmWarnf.mock.t.Fatalf("Times of LoggerMock.Warnf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarnf.expectedInvocations, n)
	return mmWarnf
}

func (mmWarnf *mLoggerMockWarnf) invocationsDone() bool {
	if len(mmWarnf.expectations) == 0 && mmWarnf.defaultExpectation == nil && mmWarnf.mock.funcWarnf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarnf.mock.afterWarnfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarnf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warnf implements logger.Logger
func (mmWarnf *LoggerMock) Warnf(ctx context.Context, m string, args ...any) {
	mm_atomic.AddUint64(&mmWarnf.beforeWarnfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnf.afterWarnfCounter, 1)

	if mmWarnf.inspectFuncWarnf != nil {
		mmWarnf.inspectFuncWarnf(ctx, m, args...)
	}

	mm_params := LoggerMockWarnfParams{ctx, m, args}

	// Record call args
	mmWarnf.WarnfMock.mutex.Lock()
	mmWarnf.WarnfMock.callArgs = append(mmWarnf.WarnfMock.callArgs, &mm_params)
	mmWarnf.WarnfMock.mutex.Unlock()

	for _, e := range mmWarnf.WarnfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnf.WarnfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnf.WarnfMock.defaultExpectation.Counter, 1)
		mm_want := mmWarnf.WarnfMock.defaultExpectation.params
		mm_want_ptrs := mmWarnf.WarnfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnfParams{ctx, m, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m != nil && !minimock.Equal(*mm_want_ptrs.m, mm_got.m) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter m, want: %#v, got: %#v%s\n", *mm_want_ptrs.m, mm_got.m, minimock.Diff(*mm_want_ptrs.m, mm_got.m))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarnf.funcWarnf != nil {
		mmWarnf.funcWarnf(ctx, m, args...)
		return
	}
	mmWarnf.t.Fatalf("Unexpected call to LoggerMock.Warnf. %v %v %v", ctx, m, args)

}

// WarnfAfterCounter returns a count of finished LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.afterWarnfCounter)
}

// WarnfBeforeCounter returns a count of LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.beforeWarnfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warnf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnf *mLoggerMockWarnf) Calls() []*LoggerMockWarnfParams {
	mmWarnf.mutex.RLock()

	argCopy := make([]*LoggerMockWarnfParams, len(mmWarnf.callArgs))
	copy(argCopy, mmWarnf.callArgs)

	mmWarnf.mutex.RUnlock()

	return argCopy
}

// MinimockWarnfDone returns true if the count of the Warnf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnfDone() bool {
	if m.WarnfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnfMock.invocationsDone()
}

// MinimockWarnfInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnfInspect() {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *e.params)
		}
	}

	afterWarnfCounter := mm_atomic.LoadUint64(&m.afterWarnfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && afterWarnfCounter < 1 {
		if m.WarnfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warnf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *m.WarnfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && afterWarnfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Warnf")
	}

	if !m.WarnfMock.invocationsDone() && afterWarnfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warnf but found %d calls",
			mm_atomic.LoadUint64(&m.WarnfMock.expectedInvocations), afterWarnfCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockDebugInspect()

			m.MinimockDebugfInspect()

			m.MinimockErrorInspect()

			m.MinimockErrorfInspect()

			m.MinimockFatalInspect()

			m.MinimockFatalfInspect()

			m.MinimockInfoInspect()

			m.MinimockInfofInspect()

			m.MinimockPanicInspect()

			m.MinimockPanicfInspect()

			m.MinimockWarnInspect()

			m.MinimockWarnfInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockDebugDone() &&
		m.MinimockDebugfDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockFatalDone() &&
		m.MinimockFatalfDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfofDone() &&
		m.MinimockPanicDone() &&
		m.MinimockPanicfDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWarnfDone()
}
