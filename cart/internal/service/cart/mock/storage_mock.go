// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/xloroff/ozon-hw-go/cart/internal/repository/memory_store.Storage -o storage_mock.go -n StorageMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/xloroff/ozon-hw-go/cart/internal/model"
)

// StorageMock implements memorystore.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, item *model.AddItem) (err error)
	inspectFuncAddItem   func(ctx context.Context, item *model.AddItem)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mStorageMockAddItem

	funcDelCart          func(ctx context.Context, userID int64) (err error)
	inspectFuncDelCart   func(ctx context.Context, userID int64)
	afterDelCartCounter  uint64
	beforeDelCartCounter uint64
	DelCartMock          mStorageMockDelCart

	funcDelItem          func(ctx context.Context, item *model.DelItem) (b1 bool)
	inspectFuncDelItem   func(ctx context.Context, item *model.DelItem)
	afterDelItemCounter  uint64
	beforeDelItemCounter uint64
	DelItemMock          mStorageMockDelItem

	funcGetAllUserItems          func(ctx context.Context, userID int64) (cp1 *model.Cart, err error)
	inspectFuncGetAllUserItems   func(ctx context.Context, userID int64)
	afterGetAllUserItemsCounter  uint64
	beforeGetAllUserItemsCounter uint64
	GetAllUserItemsMock          mStorageMockGetAllUserItems
}

// NewStorageMock returns a mock for memorystore.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mStorageMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*StorageMockAddItemParams{}

	m.DelCartMock = mStorageMockDelCart{mock: m}
	m.DelCartMock.callArgs = []*StorageMockDelCartParams{}

	m.DelItemMock = mStorageMockDelItem{mock: m}
	m.DelItemMock.callArgs = []*StorageMockDelItemParams{}

	m.GetAllUserItemsMock = mStorageMockGetAllUserItems{mock: m}
	m.GetAllUserItemsMock.callArgs = []*StorageMockGetAllUserItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockAddItem struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockAddItemExpectation
	expectations       []*StorageMockAddItemExpectation

	callArgs []*StorageMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageMockAddItemExpectation specifies expectation struct of the Storage.AddItem
type StorageMockAddItemExpectation struct {
	mock      *StorageMock
	params    *StorageMockAddItemParams
	paramPtrs *StorageMockAddItemParamPtrs
	results   *StorageMockAddItemResults
	Counter   uint64
}

// StorageMockAddItemParams contains parameters of the Storage.AddItem
type StorageMockAddItemParams struct {
	ctx  context.Context
	item *model.AddItem
}

// StorageMockAddItemParamPtrs contains pointers to parameters of the Storage.AddItem
type StorageMockAddItemParamPtrs struct {
	ctx  *context.Context
	item **model.AddItem
}

// StorageMockAddItemResults contains results of the Storage.AddItem
type StorageMockAddItemResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mStorageMockAddItem) Optional() *mStorageMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for Storage.AddItem
func (mmAddItem *mStorageMockAddItem) Expect(ctx context.Context, item *model.AddItem) *mStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &StorageMockAddItemParams{ctx, item}
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for Storage.AddItem
func (mmAddItem *mStorageMockAddItem) ExpectCtxParam1(ctx context.Context) *mStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &StorageMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddItem
}

// ExpectItemParam2 sets up expected param item for Storage.AddItem
func (mmAddItem *mStorageMockAddItem) ExpectItemParam2(item *model.AddItem) *mStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &StorageMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.item = &item

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddItem
func (mmAddItem *mStorageMockAddItem) Inspect(f func(ctx context.Context, item *model.AddItem)) *mStorageMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for StorageMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by Storage.AddItem
func (mmAddItem *mStorageMockAddItem) Return(err error) *StorageMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &StorageMockAddItemResults{err}
	return mmAddItem.mock
}

// Set uses given function f to mock the Storage.AddItem method
func (mmAddItem *mStorageMockAddItem) Set(f func(ctx context.Context, item *model.AddItem) (err error)) *StorageMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the Storage.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the Storage.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	return mmAddItem.mock
}

// When sets expectation for the Storage.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mStorageMockAddItem) When(ctx context.Context, item *model.AddItem) *StorageMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	expectation := &StorageMockAddItemExpectation{
		mock:   mmAddItem.mock,
		params: &StorageMockAddItemParams{ctx, item},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddItem return parameters for the expectation previously defined by the When method
func (e *StorageMockAddItemExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockAddItemResults{err}
	return e.mock
}

// Times sets number of times Storage.AddItem should be invoked
func (mmAddItem *mStorageMockAddItem) Times(n uint64) *mStorageMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of StorageMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	return mmAddItem
}

func (mmAddItem *mStorageMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements memorystore.Storage
func (mmAddItem *StorageMock) AddItem(ctx context.Context, item *model.AddItem) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, item)
	}

	mm_params := StorageMockAddItemParams{ctx, item}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := StorageMockAddItemParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("StorageMock.AddItem got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmAddItem.t.Errorf("StorageMock.AddItem got unexpected parameter item, want: %#v, got: %#v%s\n", *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("StorageMock.AddItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the StorageMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, item)
	}
	mmAddItem.t.Fatalf("Unexpected call to StorageMock.AddItem. %v %v", ctx, item)
	return
}

// AddItemAfterCounter returns a count of finished StorageMock.AddItem invocations
func (mmAddItem *StorageMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of StorageMock.AddItem invocations
func (mmAddItem *StorageMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mStorageMockAddItem) Calls() []*StorageMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*StorageMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *StorageMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.AddItem with params: %#v", *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.AddItem")
		} else {
			m.t.Errorf("Expected call to StorageMock.AddItem with params: %#v", *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Error("Expected call to StorageMock.AddItem")
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.AddItem but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), afterAddItemCounter)
	}
}

type mStorageMockDelCart struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockDelCartExpectation
	expectations       []*StorageMockDelCartExpectation

	callArgs []*StorageMockDelCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageMockDelCartExpectation specifies expectation struct of the Storage.DelCart
type StorageMockDelCartExpectation struct {
	mock      *StorageMock
	params    *StorageMockDelCartParams
	paramPtrs *StorageMockDelCartParamPtrs
	results   *StorageMockDelCartResults
	Counter   uint64
}

// StorageMockDelCartParams contains parameters of the Storage.DelCart
type StorageMockDelCartParams struct {
	ctx    context.Context
	userID int64
}

// StorageMockDelCartParamPtrs contains pointers to parameters of the Storage.DelCart
type StorageMockDelCartParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// StorageMockDelCartResults contains results of the Storage.DelCart
type StorageMockDelCartResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelCart *mStorageMockDelCart) Optional() *mStorageMockDelCart {
	mmDelCart.optional = true
	return mmDelCart
}

// Expect sets up expected params for Storage.DelCart
func (mmDelCart *mStorageMockDelCart) Expect(ctx context.Context, userID int64) *mStorageMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("StorageMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &StorageMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.paramPtrs != nil {
		mmDelCart.mock.t.Fatalf("StorageMock.DelCart mock is already set by ExpectParams functions")
	}

	mmDelCart.defaultExpectation.params = &StorageMockDelCartParams{ctx, userID}
	for _, e := range mmDelCart.expectations {
		if minimock.Equal(e.params, mmDelCart.defaultExpectation.params) {
			mmDelCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelCart.defaultExpectation.params)
		}
	}

	return mmDelCart
}

// ExpectCtxParam1 sets up expected param ctx for Storage.DelCart
func (mmDelCart *mStorageMockDelCart) ExpectCtxParam1(ctx context.Context) *mStorageMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("StorageMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &StorageMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.params != nil {
		mmDelCart.mock.t.Fatalf("StorageMock.DelCart mock is already set by Expect")
	}

	if mmDelCart.defaultExpectation.paramPtrs == nil {
		mmDelCart.defaultExpectation.paramPtrs = &StorageMockDelCartParamPtrs{}
	}
	mmDelCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelCart
}

// ExpectUserIDParam2 sets up expected param userID for Storage.DelCart
func (mmDelCart *mStorageMockDelCart) ExpectUserIDParam2(userID int64) *mStorageMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("StorageMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &StorageMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.params != nil {
		mmDelCart.mock.t.Fatalf("StorageMock.DelCart mock is already set by Expect")
	}

	if mmDelCart.defaultExpectation.paramPtrs == nil {
		mmDelCart.defaultExpectation.paramPtrs = &StorageMockDelCartParamPtrs{}
	}
	mmDelCart.defaultExpectation.paramPtrs.userID = &userID

	return mmDelCart
}

// Inspect accepts an inspector function that has same arguments as the Storage.DelCart
func (mmDelCart *mStorageMockDelCart) Inspect(f func(ctx context.Context, userID int64)) *mStorageMockDelCart {
	if mmDelCart.mock.inspectFuncDelCart != nil {
		mmDelCart.mock.t.Fatalf("Inspect function is already set for StorageMock.DelCart")
	}

	mmDelCart.mock.inspectFuncDelCart = f

	return mmDelCart
}

// Return sets up results that will be returned by Storage.DelCart
func (mmDelCart *mStorageMockDelCart) Return(err error) *StorageMock {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("StorageMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &StorageMockDelCartExpectation{mock: mmDelCart.mock}
	}
	mmDelCart.defaultExpectation.results = &StorageMockDelCartResults{err}
	return mmDelCart.mock
}

// Set uses given function f to mock the Storage.DelCart method
func (mmDelCart *mStorageMockDelCart) Set(f func(ctx context.Context, userID int64) (err error)) *StorageMock {
	if mmDelCart.defaultExpectation != nil {
		mmDelCart.mock.t.Fatalf("Default expectation is already set for the Storage.DelCart method")
	}

	if len(mmDelCart.expectations) > 0 {
		mmDelCart.mock.t.Fatalf("Some expectations are already set for the Storage.DelCart method")
	}

	mmDelCart.mock.funcDelCart = f
	return mmDelCart.mock
}

// When sets expectation for the Storage.DelCart which will trigger the result defined by the following
// Then helper
func (mmDelCart *mStorageMockDelCart) When(ctx context.Context, userID int64) *StorageMockDelCartExpectation {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("StorageMock.DelCart mock is already set by Set")
	}

	expectation := &StorageMockDelCartExpectation{
		mock:   mmDelCart.mock,
		params: &StorageMockDelCartParams{ctx, userID},
	}
	mmDelCart.expectations = append(mmDelCart.expectations, expectation)
	return expectation
}

// Then sets up Storage.DelCart return parameters for the expectation previously defined by the When method
func (e *StorageMockDelCartExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockDelCartResults{err}
	return e.mock
}

// Times sets number of times Storage.DelCart should be invoked
func (mmDelCart *mStorageMockDelCart) Times(n uint64) *mStorageMockDelCart {
	if n == 0 {
		mmDelCart.mock.t.Fatalf("Times of StorageMock.DelCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelCart.expectedInvocations, n)
	return mmDelCart
}

func (mmDelCart *mStorageMockDelCart) invocationsDone() bool {
	if len(mmDelCart.expectations) == 0 && mmDelCart.defaultExpectation == nil && mmDelCart.mock.funcDelCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelCart.mock.afterDelCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DelCart implements memorystore.Storage
func (mmDelCart *StorageMock) DelCart(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmDelCart.beforeDelCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDelCart.afterDelCartCounter, 1)

	if mmDelCart.inspectFuncDelCart != nil {
		mmDelCart.inspectFuncDelCart(ctx, userID)
	}

	mm_params := StorageMockDelCartParams{ctx, userID}

	// Record call args
	mmDelCart.DelCartMock.mutex.Lock()
	mmDelCart.DelCartMock.callArgs = append(mmDelCart.DelCartMock.callArgs, &mm_params)
	mmDelCart.DelCartMock.mutex.Unlock()

	for _, e := range mmDelCart.DelCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelCart.DelCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelCart.DelCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDelCart.DelCartMock.defaultExpectation.params
		mm_want_ptrs := mmDelCart.DelCartMock.defaultExpectation.paramPtrs

		mm_got := StorageMockDelCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelCart.t.Errorf("StorageMock.DelCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDelCart.t.Errorf("StorageMock.DelCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelCart.t.Errorf("StorageMock.DelCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelCart.DelCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDelCart.t.Fatal("No results are set for the StorageMock.DelCart")
		}
		return (*mm_results).err
	}
	if mmDelCart.funcDelCart != nil {
		return mmDelCart.funcDelCart(ctx, userID)
	}
	mmDelCart.t.Fatalf("Unexpected call to StorageMock.DelCart. %v %v", ctx, userID)
	return
}

// DelCartAfterCounter returns a count of finished StorageMock.DelCart invocations
func (mmDelCart *StorageMock) DelCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelCart.afterDelCartCounter)
}

// DelCartBeforeCounter returns a count of StorageMock.DelCart invocations
func (mmDelCart *StorageMock) DelCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelCart.beforeDelCartCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.DelCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelCart *mStorageMockDelCart) Calls() []*StorageMockDelCartParams {
	mmDelCart.mutex.RLock()

	argCopy := make([]*StorageMockDelCartParams, len(mmDelCart.callArgs))
	copy(argCopy, mmDelCart.callArgs)

	mmDelCart.mutex.RUnlock()

	return argCopy
}

// MinimockDelCartDone returns true if the count of the DelCart invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDelCartDone() bool {
	if m.DelCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DelCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DelCartMock.invocationsDone()
}

// MinimockDelCartInspect logs each unmet expectation
func (m *StorageMock) MinimockDelCartInspect() {
	for _, e := range m.DelCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.DelCart with params: %#v", *e.params)
		}
	}

	afterDelCartCounter := mm_atomic.LoadUint64(&m.afterDelCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DelCartMock.defaultExpectation != nil && afterDelCartCounter < 1 {
		if m.DelCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.DelCart")
		} else {
			m.t.Errorf("Expected call to StorageMock.DelCart with params: %#v", *m.DelCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelCart != nil && afterDelCartCounter < 1 {
		m.t.Error("Expected call to StorageMock.DelCart")
	}

	if !m.DelCartMock.invocationsDone() && afterDelCartCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.DelCart but found %d calls",
			mm_atomic.LoadUint64(&m.DelCartMock.expectedInvocations), afterDelCartCounter)
	}
}

type mStorageMockDelItem struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockDelItemExpectation
	expectations       []*StorageMockDelItemExpectation

	callArgs []*StorageMockDelItemParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageMockDelItemExpectation specifies expectation struct of the Storage.DelItem
type StorageMockDelItemExpectation struct {
	mock      *StorageMock
	params    *StorageMockDelItemParams
	paramPtrs *StorageMockDelItemParamPtrs
	results   *StorageMockDelItemResults
	Counter   uint64
}

// StorageMockDelItemParams contains parameters of the Storage.DelItem
type StorageMockDelItemParams struct {
	ctx  context.Context
	item *model.DelItem
}

// StorageMockDelItemParamPtrs contains pointers to parameters of the Storage.DelItem
type StorageMockDelItemParamPtrs struct {
	ctx  *context.Context
	item **model.DelItem
}

// StorageMockDelItemResults contains results of the Storage.DelItem
type StorageMockDelItemResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelItem *mStorageMockDelItem) Optional() *mStorageMockDelItem {
	mmDelItem.optional = true
	return mmDelItem
}

// Expect sets up expected params for Storage.DelItem
func (mmDelItem *mStorageMockDelItem) Expect(ctx context.Context, item *model.DelItem) *mStorageMockDelItem {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("StorageMock.DelItem mock is already set by Set")
	}

	if mmDelItem.defaultExpectation == nil {
		mmDelItem.defaultExpectation = &StorageMockDelItemExpectation{}
	}

	if mmDelItem.defaultExpectation.paramPtrs != nil {
		mmDelItem.mock.t.Fatalf("StorageMock.DelItem mock is already set by ExpectParams functions")
	}

	mmDelItem.defaultExpectation.params = &StorageMockDelItemParams{ctx, item}
	for _, e := range mmDelItem.expectations {
		if minimock.Equal(e.params, mmDelItem.defaultExpectation.params) {
			mmDelItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelItem.defaultExpectation.params)
		}
	}

	return mmDelItem
}

// ExpectCtxParam1 sets up expected param ctx for Storage.DelItem
func (mmDelItem *mStorageMockDelItem) ExpectCtxParam1(ctx context.Context) *mStorageMockDelItem {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("StorageMock.DelItem mock is already set by Set")
	}

	if mmDelItem.defaultExpectation == nil {
		mmDelItem.defaultExpectation = &StorageMockDelItemExpectation{}
	}

	if mmDelItem.defaultExpectation.params != nil {
		mmDelItem.mock.t.Fatalf("StorageMock.DelItem mock is already set by Expect")
	}

	if mmDelItem.defaultExpectation.paramPtrs == nil {
		mmDelItem.defaultExpectation.paramPtrs = &StorageMockDelItemParamPtrs{}
	}
	mmDelItem.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelItem
}

// ExpectItemParam2 sets up expected param item for Storage.DelItem
func (mmDelItem *mStorageMockDelItem) ExpectItemParam2(item *model.DelItem) *mStorageMockDelItem {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("StorageMock.DelItem mock is already set by Set")
	}

	if mmDelItem.defaultExpectation == nil {
		mmDelItem.defaultExpectation = &StorageMockDelItemExpectation{}
	}

	if mmDelItem.defaultExpectation.params != nil {
		mmDelItem.mock.t.Fatalf("StorageMock.DelItem mock is already set by Expect")
	}

	if mmDelItem.defaultExpectation.paramPtrs == nil {
		mmDelItem.defaultExpectation.paramPtrs = &StorageMockDelItemParamPtrs{}
	}
	mmDelItem.defaultExpectation.paramPtrs.item = &item

	return mmDelItem
}

// Inspect accepts an inspector function that has same arguments as the Storage.DelItem
func (mmDelItem *mStorageMockDelItem) Inspect(f func(ctx context.Context, item *model.DelItem)) *mStorageMockDelItem {
	if mmDelItem.mock.inspectFuncDelItem != nil {
		mmDelItem.mock.t.Fatalf("Inspect function is already set for StorageMock.DelItem")
	}

	mmDelItem.mock.inspectFuncDelItem = f

	return mmDelItem
}

// Return sets up results that will be returned by Storage.DelItem
func (mmDelItem *mStorageMockDelItem) Return(b1 bool) *StorageMock {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("StorageMock.DelItem mock is already set by Set")
	}

	if mmDelItem.defaultExpectation == nil {
		mmDelItem.defaultExpectation = &StorageMockDelItemExpectation{mock: mmDelItem.mock}
	}
	mmDelItem.defaultExpectation.results = &StorageMockDelItemResults{b1}
	return mmDelItem.mock
}

// Set uses given function f to mock the Storage.DelItem method
func (mmDelItem *mStorageMockDelItem) Set(f func(ctx context.Context, item *model.DelItem) (b1 bool)) *StorageMock {
	if mmDelItem.defaultExpectation != nil {
		mmDelItem.mock.t.Fatalf("Default expectation is already set for the Storage.DelItem method")
	}

	if len(mmDelItem.expectations) > 0 {
		mmDelItem.mock.t.Fatalf("Some expectations are already set for the Storage.DelItem method")
	}

	mmDelItem.mock.funcDelItem = f
	return mmDelItem.mock
}

// When sets expectation for the Storage.DelItem which will trigger the result defined by the following
// Then helper
func (mmDelItem *mStorageMockDelItem) When(ctx context.Context, item *model.DelItem) *StorageMockDelItemExpectation {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("StorageMock.DelItem mock is already set by Set")
	}

	expectation := &StorageMockDelItemExpectation{
		mock:   mmDelItem.mock,
		params: &StorageMockDelItemParams{ctx, item},
	}
	mmDelItem.expectations = append(mmDelItem.expectations, expectation)
	return expectation
}

// Then sets up Storage.DelItem return parameters for the expectation previously defined by the When method
func (e *StorageMockDelItemExpectation) Then(b1 bool) *StorageMock {
	e.results = &StorageMockDelItemResults{b1}
	return e.mock
}

// Times sets number of times Storage.DelItem should be invoked
func (mmDelItem *mStorageMockDelItem) Times(n uint64) *mStorageMockDelItem {
	if n == 0 {
		mmDelItem.mock.t.Fatalf("Times of StorageMock.DelItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelItem.expectedInvocations, n)
	return mmDelItem
}

func (mmDelItem *mStorageMockDelItem) invocationsDone() bool {
	if len(mmDelItem.expectations) == 0 && mmDelItem.defaultExpectation == nil && mmDelItem.mock.funcDelItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelItem.mock.afterDelItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DelItem implements memorystore.Storage
func (mmDelItem *StorageMock) DelItem(ctx context.Context, item *model.DelItem) (b1 bool) {
	mm_atomic.AddUint64(&mmDelItem.beforeDelItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDelItem.afterDelItemCounter, 1)

	if mmDelItem.inspectFuncDelItem != nil {
		mmDelItem.inspectFuncDelItem(ctx, item)
	}

	mm_params := StorageMockDelItemParams{ctx, item}

	// Record call args
	mmDelItem.DelItemMock.mutex.Lock()
	mmDelItem.DelItemMock.callArgs = append(mmDelItem.DelItemMock.callArgs, &mm_params)
	mmDelItem.DelItemMock.mutex.Unlock()

	for _, e := range mmDelItem.DelItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmDelItem.DelItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelItem.DelItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDelItem.DelItemMock.defaultExpectation.params
		mm_want_ptrs := mmDelItem.DelItemMock.defaultExpectation.paramPtrs

		mm_got := StorageMockDelItemParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelItem.t.Errorf("StorageMock.DelItem got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmDelItem.t.Errorf("StorageMock.DelItem got unexpected parameter item, want: %#v, got: %#v%s\n", *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelItem.t.Errorf("StorageMock.DelItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelItem.DelItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDelItem.t.Fatal("No results are set for the StorageMock.DelItem")
		}
		return (*mm_results).b1
	}
	if mmDelItem.funcDelItem != nil {
		return mmDelItem.funcDelItem(ctx, item)
	}
	mmDelItem.t.Fatalf("Unexpected call to StorageMock.DelItem. %v %v", ctx, item)
	return
}

// DelItemAfterCounter returns a count of finished StorageMock.DelItem invocations
func (mmDelItem *StorageMock) DelItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelItem.afterDelItemCounter)
}

// DelItemBeforeCounter returns a count of StorageMock.DelItem invocations
func (mmDelItem *StorageMock) DelItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelItem.beforeDelItemCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.DelItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelItem *mStorageMockDelItem) Calls() []*StorageMockDelItemParams {
	mmDelItem.mutex.RLock()

	argCopy := make([]*StorageMockDelItemParams, len(mmDelItem.callArgs))
	copy(argCopy, mmDelItem.callArgs)

	mmDelItem.mutex.RUnlock()

	return argCopy
}

// MinimockDelItemDone returns true if the count of the DelItem invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDelItemDone() bool {
	if m.DelItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DelItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DelItemMock.invocationsDone()
}

// MinimockDelItemInspect logs each unmet expectation
func (m *StorageMock) MinimockDelItemInspect() {
	for _, e := range m.DelItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.DelItem with params: %#v", *e.params)
		}
	}

	afterDelItemCounter := mm_atomic.LoadUint64(&m.afterDelItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DelItemMock.defaultExpectation != nil && afterDelItemCounter < 1 {
		if m.DelItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.DelItem")
		} else {
			m.t.Errorf("Expected call to StorageMock.DelItem with params: %#v", *m.DelItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelItem != nil && afterDelItemCounter < 1 {
		m.t.Error("Expected call to StorageMock.DelItem")
	}

	if !m.DelItemMock.invocationsDone() && afterDelItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.DelItem but found %d calls",
			mm_atomic.LoadUint64(&m.DelItemMock.expectedInvocations), afterDelItemCounter)
	}
}

type mStorageMockGetAllUserItems struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetAllUserItemsExpectation
	expectations       []*StorageMockGetAllUserItemsExpectation

	callArgs []*StorageMockGetAllUserItemsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageMockGetAllUserItemsExpectation specifies expectation struct of the Storage.GetAllUserItems
type StorageMockGetAllUserItemsExpectation struct {
	mock      *StorageMock
	params    *StorageMockGetAllUserItemsParams
	paramPtrs *StorageMockGetAllUserItemsParamPtrs
	results   *StorageMockGetAllUserItemsResults
	Counter   uint64
}

// StorageMockGetAllUserItemsParams contains parameters of the Storage.GetAllUserItems
type StorageMockGetAllUserItemsParams struct {
	ctx    context.Context
	userID int64
}

// StorageMockGetAllUserItemsParamPtrs contains pointers to parameters of the Storage.GetAllUserItems
type StorageMockGetAllUserItemsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// StorageMockGetAllUserItemsResults contains results of the Storage.GetAllUserItems
type StorageMockGetAllUserItemsResults struct {
	cp1 *model.Cart
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllUserItems *mStorageMockGetAllUserItems) Optional() *mStorageMockGetAllUserItems {
	mmGetAllUserItems.optional = true
	return mmGetAllUserItems
}

// Expect sets up expected params for Storage.GetAllUserItems
func (mmGetAllUserItems *mStorageMockGetAllUserItems) Expect(ctx context.Context, userID int64) *mStorageMockGetAllUserItems {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("StorageMock.GetAllUserItems mock is already set by Set")
	}

	if mmGetAllUserItems.defaultExpectation == nil {
		mmGetAllUserItems.defaultExpectation = &StorageMockGetAllUserItemsExpectation{}
	}

	if mmGetAllUserItems.defaultExpectation.paramPtrs != nil {
		mmGetAllUserItems.mock.t.Fatalf("StorageMock.GetAllUserItems mock is already set by ExpectParams functions")
	}

	mmGetAllUserItems.defaultExpectation.params = &StorageMockGetAllUserItemsParams{ctx, userID}
	for _, e := range mmGetAllUserItems.expectations {
		if minimock.Equal(e.params, mmGetAllUserItems.defaultExpectation.params) {
			mmGetAllUserItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllUserItems.defaultExpectation.params)
		}
	}

	return mmGetAllUserItems
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetAllUserItems
func (mmGetAllUserItems *mStorageMockGetAllUserItems) ExpectCtxParam1(ctx context.Context) *mStorageMockGetAllUserItems {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("StorageMock.GetAllUserItems mock is already set by Set")
	}

	if mmGetAllUserItems.defaultExpectation == nil {
		mmGetAllUserItems.defaultExpectation = &StorageMockGetAllUserItemsExpectation{}
	}

	if mmGetAllUserItems.defaultExpectation.params != nil {
		mmGetAllUserItems.mock.t.Fatalf("StorageMock.GetAllUserItems mock is already set by Expect")
	}

	if mmGetAllUserItems.defaultExpectation.paramPtrs == nil {
		mmGetAllUserItems.defaultExpectation.paramPtrs = &StorageMockGetAllUserItemsParamPtrs{}
	}
	mmGetAllUserItems.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAllUserItems
}

// ExpectUserIDParam2 sets up expected param userID for Storage.GetAllUserItems
func (mmGetAllUserItems *mStorageMockGetAllUserItems) ExpectUserIDParam2(userID int64) *mStorageMockGetAllUserItems {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("StorageMock.GetAllUserItems mock is already set by Set")
	}

	if mmGetAllUserItems.defaultExpectation == nil {
		mmGetAllUserItems.defaultExpectation = &StorageMockGetAllUserItemsExpectation{}
	}

	if mmGetAllUserItems.defaultExpectation.params != nil {
		mmGetAllUserItems.mock.t.Fatalf("StorageMock.GetAllUserItems mock is already set by Expect")
	}

	if mmGetAllUserItems.defaultExpectation.paramPtrs == nil {
		mmGetAllUserItems.defaultExpectation.paramPtrs = &StorageMockGetAllUserItemsParamPtrs{}
	}
	mmGetAllUserItems.defaultExpectation.paramPtrs.userID = &userID

	return mmGetAllUserItems
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetAllUserItems
func (mmGetAllUserItems *mStorageMockGetAllUserItems) Inspect(f func(ctx context.Context, userID int64)) *mStorageMockGetAllUserItems {
	if mmGetAllUserItems.mock.inspectFuncGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("Inspect function is already set for StorageMock.GetAllUserItems")
	}

	mmGetAllUserItems.mock.inspectFuncGetAllUserItems = f

	return mmGetAllUserItems
}

// Return sets up results that will be returned by Storage.GetAllUserItems
func (mmGetAllUserItems *mStorageMockGetAllUserItems) Return(cp1 *model.Cart, err error) *StorageMock {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("StorageMock.GetAllUserItems mock is already set by Set")
	}

	if mmGetAllUserItems.defaultExpectation == nil {
		mmGetAllUserItems.defaultExpectation = &StorageMockGetAllUserItemsExpectation{mock: mmGetAllUserItems.mock}
	}
	mmGetAllUserItems.defaultExpectation.results = &StorageMockGetAllUserItemsResults{cp1, err}
	return mmGetAllUserItems.mock
}

// Set uses given function f to mock the Storage.GetAllUserItems method
func (mmGetAllUserItems *mStorageMockGetAllUserItems) Set(f func(ctx context.Context, userID int64) (cp1 *model.Cart, err error)) *StorageMock {
	if mmGetAllUserItems.defaultExpectation != nil {
		mmGetAllUserItems.mock.t.Fatalf("Default expectation is already set for the Storage.GetAllUserItems method")
	}

	if len(mmGetAllUserItems.expectations) > 0 {
		mmGetAllUserItems.mock.t.Fatalf("Some expectations are already set for the Storage.GetAllUserItems method")
	}

	mmGetAllUserItems.mock.funcGetAllUserItems = f
	return mmGetAllUserItems.mock
}

// When sets expectation for the Storage.GetAllUserItems which will trigger the result defined by the following
// Then helper
func (mmGetAllUserItems *mStorageMockGetAllUserItems) When(ctx context.Context, userID int64) *StorageMockGetAllUserItemsExpectation {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("StorageMock.GetAllUserItems mock is already set by Set")
	}

	expectation := &StorageMockGetAllUserItemsExpectation{
		mock:   mmGetAllUserItems.mock,
		params: &StorageMockGetAllUserItemsParams{ctx, userID},
	}
	mmGetAllUserItems.expectations = append(mmGetAllUserItems.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetAllUserItems return parameters for the expectation previously defined by the When method
func (e *StorageMockGetAllUserItemsExpectation) Then(cp1 *model.Cart, err error) *StorageMock {
	e.results = &StorageMockGetAllUserItemsResults{cp1, err}
	return e.mock
}

// Times sets number of times Storage.GetAllUserItems should be invoked
func (mmGetAllUserItems *mStorageMockGetAllUserItems) Times(n uint64) *mStorageMockGetAllUserItems {
	if n == 0 {
		mmGetAllUserItems.mock.t.Fatalf("Times of StorageMock.GetAllUserItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllUserItems.expectedInvocations, n)
	return mmGetAllUserItems
}

func (mmGetAllUserItems *mStorageMockGetAllUserItems) invocationsDone() bool {
	if len(mmGetAllUserItems.expectations) == 0 && mmGetAllUserItems.defaultExpectation == nil && mmGetAllUserItems.mock.funcGetAllUserItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllUserItems.mock.afterGetAllUserItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllUserItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllUserItems implements memorystore.Storage
func (mmGetAllUserItems *StorageMock) GetAllUserItems(ctx context.Context, userID int64) (cp1 *model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetAllUserItems.beforeGetAllUserItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllUserItems.afterGetAllUserItemsCounter, 1)

	if mmGetAllUserItems.inspectFuncGetAllUserItems != nil {
		mmGetAllUserItems.inspectFuncGetAllUserItems(ctx, userID)
	}

	mm_params := StorageMockGetAllUserItemsParams{ctx, userID}

	// Record call args
	mmGetAllUserItems.GetAllUserItemsMock.mutex.Lock()
	mmGetAllUserItems.GetAllUserItemsMock.callArgs = append(mmGetAllUserItems.GetAllUserItemsMock.callArgs, &mm_params)
	mmGetAllUserItems.GetAllUserItemsMock.mutex.Unlock()

	for _, e := range mmGetAllUserItems.GetAllUserItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetAllUserItemsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllUserItems.t.Errorf("StorageMock.GetAllUserItems got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetAllUserItems.t.Errorf("StorageMock.GetAllUserItems got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllUserItems.t.Errorf("StorageMock.GetAllUserItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllUserItems.t.Fatal("No results are set for the StorageMock.GetAllUserItems")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetAllUserItems.funcGetAllUserItems != nil {
		return mmGetAllUserItems.funcGetAllUserItems(ctx, userID)
	}
	mmGetAllUserItems.t.Fatalf("Unexpected call to StorageMock.GetAllUserItems. %v %v", ctx, userID)
	return
}

// GetAllUserItemsAfterCounter returns a count of finished StorageMock.GetAllUserItems invocations
func (mmGetAllUserItems *StorageMock) GetAllUserItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUserItems.afterGetAllUserItemsCounter)
}

// GetAllUserItemsBeforeCounter returns a count of StorageMock.GetAllUserItems invocations
func (mmGetAllUserItems *StorageMock) GetAllUserItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUserItems.beforeGetAllUserItemsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetAllUserItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllUserItems *mStorageMockGetAllUserItems) Calls() []*StorageMockGetAllUserItemsParams {
	mmGetAllUserItems.mutex.RLock()

	argCopy := make([]*StorageMockGetAllUserItemsParams, len(mmGetAllUserItems.callArgs))
	copy(argCopy, mmGetAllUserItems.callArgs)

	mmGetAllUserItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllUserItemsDone returns true if the count of the GetAllUserItems invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetAllUserItemsDone() bool {
	if m.GetAllUserItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllUserItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllUserItemsMock.invocationsDone()
}

// MinimockGetAllUserItemsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetAllUserItemsInspect() {
	for _, e := range m.GetAllUserItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetAllUserItems with params: %#v", *e.params)
		}
	}

	afterGetAllUserItemsCounter := mm_atomic.LoadUint64(&m.afterGetAllUserItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllUserItemsMock.defaultExpectation != nil && afterGetAllUserItemsCounter < 1 {
		if m.GetAllUserItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetAllUserItems")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetAllUserItems with params: %#v", *m.GetAllUserItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllUserItems != nil && afterGetAllUserItemsCounter < 1 {
		m.t.Error("Expected call to StorageMock.GetAllUserItems")
	}

	if !m.GetAllUserItemsMock.invocationsDone() && afterGetAllUserItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetAllUserItems but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllUserItemsMock.expectedInvocations), afterGetAllUserItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDelCartInspect()

			m.MinimockDelItemInspect()

			m.MinimockGetAllUserItemsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDelCartDone() &&
		m.MinimockDelItemDone() &&
		m.MinimockGetAllUserItemsDone()
}
