// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/xloroff/ozon-hw-go/cart/internal/service/cart.Service -o service_mock.go -n ServiceMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/xloroff/ozon-hw-go/cart/internal/model"
)

// ServiceMock implements cart.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, item *model.AddItem) (err error)
	inspectFuncAddItem   func(ctx context.Context, item *model.AddItem)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mServiceMockAddItem

	funcCheckout          func(ctx context.Context, userID int64) (op1 *model.OrderCart, err error)
	inspectFuncCheckout   func(ctx context.Context, userID int64)
	afterCheckoutCounter  uint64
	beforeCheckoutCounter uint64
	CheckoutMock          mServiceMockCheckout

	funcDelCart          func(ctx context.Context, userID int64) (err error)
	inspectFuncDelCart   func(ctx context.Context, userID int64)
	afterDelCartCounter  uint64
	beforeDelCartCounter uint64
	DelCartMock          mServiceMockDelCart

	funcDelItem          func(ctx context.Context, item *model.DelItem) (err error)
	inspectFuncDelItem   func(ctx context.Context, item *model.DelItem)
	afterDelItemCounter  uint64
	beforeDelItemCounter uint64
	DelItemMock          mServiceMockDelItem

	funcGetAllUserItems          func(ctx context.Context, userID int64) (fp1 *model.FullUserCart, err error)
	inspectFuncGetAllUserItems   func(ctx context.Context, userID int64)
	afterGetAllUserItemsCounter  uint64
	beforeGetAllUserItemsCounter uint64
	GetAllUserItemsMock          mServiceMockGetAllUserItems
}

// NewServiceMock returns a mock for cart.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mServiceMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*ServiceMockAddItemParams{}

	m.CheckoutMock = mServiceMockCheckout{mock: m}
	m.CheckoutMock.callArgs = []*ServiceMockCheckoutParams{}

	m.DelCartMock = mServiceMockDelCart{mock: m}
	m.DelCartMock.callArgs = []*ServiceMockDelCartParams{}

	m.DelItemMock = mServiceMockDelItem{mock: m}
	m.DelItemMock.callArgs = []*ServiceMockDelItemParams{}

	m.GetAllUserItemsMock = mServiceMockGetAllUserItems{mock: m}
	m.GetAllUserItemsMock.callArgs = []*ServiceMockGetAllUserItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockAddItem struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockAddItemExpectation
	expectations       []*ServiceMockAddItemExpectation

	callArgs []*ServiceMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ServiceMockAddItemExpectation specifies expectation struct of the Service.AddItem
type ServiceMockAddItemExpectation struct {
	mock      *ServiceMock
	params    *ServiceMockAddItemParams
	paramPtrs *ServiceMockAddItemParamPtrs
	results   *ServiceMockAddItemResults
	Counter   uint64
}

// ServiceMockAddItemParams contains parameters of the Service.AddItem
type ServiceMockAddItemParams struct {
	ctx  context.Context
	item *model.AddItem
}

// ServiceMockAddItemParamPtrs contains pointers to parameters of the Service.AddItem
type ServiceMockAddItemParamPtrs struct {
	ctx  *context.Context
	item **model.AddItem
}

// ServiceMockAddItemResults contains results of the Service.AddItem
type ServiceMockAddItemResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mServiceMockAddItem) Optional() *mServiceMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for Service.AddItem
func (mmAddItem *mServiceMockAddItem) Expect(ctx context.Context, item *model.AddItem) *mServiceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &ServiceMockAddItemParams{ctx, item}
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for Service.AddItem
func (mmAddItem *mServiceMockAddItem) ExpectCtxParam1(ctx context.Context) *mServiceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ServiceMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddItem
}

// ExpectItemParam2 sets up expected param item for Service.AddItem
func (mmAddItem *mServiceMockAddItem) ExpectItemParam2(item *model.AddItem) *mServiceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ServiceMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.item = &item

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the Service.AddItem
func (mmAddItem *mServiceMockAddItem) Inspect(f func(ctx context.Context, item *model.AddItem)) *mServiceMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for ServiceMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by Service.AddItem
func (mmAddItem *mServiceMockAddItem) Return(err error) *ServiceMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &ServiceMockAddItemResults{err}
	return mmAddItem.mock
}

// Set uses given function f to mock the Service.AddItem method
func (mmAddItem *mServiceMockAddItem) Set(f func(ctx context.Context, item *model.AddItem) (err error)) *ServiceMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the Service.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the Service.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	return mmAddItem.mock
}

// When sets expectation for the Service.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mServiceMockAddItem) When(ctx context.Context, item *model.AddItem) *ServiceMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	expectation := &ServiceMockAddItemExpectation{
		mock:   mmAddItem.mock,
		params: &ServiceMockAddItemParams{ctx, item},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up Service.AddItem return parameters for the expectation previously defined by the When method
func (e *ServiceMockAddItemExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockAddItemResults{err}
	return e.mock
}

// Times sets number of times Service.AddItem should be invoked
func (mmAddItem *mServiceMockAddItem) Times(n uint64) *mServiceMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of ServiceMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	return mmAddItem
}

func (mmAddItem *mServiceMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements cart.Service
func (mmAddItem *ServiceMock) AddItem(ctx context.Context, item *model.AddItem) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, item)
	}

	mm_params := ServiceMockAddItemParams{ctx, item}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockAddItemParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("ServiceMock.AddItem got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmAddItem.t.Errorf("ServiceMock.AddItem got unexpected parameter item, want: %#v, got: %#v%s\n", *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("ServiceMock.AddItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the ServiceMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, item)
	}
	mmAddItem.t.Fatalf("Unexpected call to ServiceMock.AddItem. %v %v", ctx, item)
	return
}

// AddItemAfterCounter returns a count of finished ServiceMock.AddItem invocations
func (mmAddItem *ServiceMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of ServiceMock.AddItem invocations
func (mmAddItem *ServiceMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mServiceMockAddItem) Calls() []*ServiceMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*ServiceMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *ServiceMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.AddItem with params: %#v", *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.AddItem")
		} else {
			m.t.Errorf("Expected call to ServiceMock.AddItem with params: %#v", *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Error("Expected call to ServiceMock.AddItem")
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.AddItem but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), afterAddItemCounter)
	}
}

type mServiceMockCheckout struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckoutExpectation
	expectations       []*ServiceMockCheckoutExpectation

	callArgs []*ServiceMockCheckoutParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ServiceMockCheckoutExpectation specifies expectation struct of the Service.Checkout
type ServiceMockCheckoutExpectation struct {
	mock      *ServiceMock
	params    *ServiceMockCheckoutParams
	paramPtrs *ServiceMockCheckoutParamPtrs
	results   *ServiceMockCheckoutResults
	Counter   uint64
}

// ServiceMockCheckoutParams contains parameters of the Service.Checkout
type ServiceMockCheckoutParams struct {
	ctx    context.Context
	userID int64
}

// ServiceMockCheckoutParamPtrs contains pointers to parameters of the Service.Checkout
type ServiceMockCheckoutParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// ServiceMockCheckoutResults contains results of the Service.Checkout
type ServiceMockCheckoutResults struct {
	op1 *model.OrderCart
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckout *mServiceMockCheckout) Optional() *mServiceMockCheckout {
	mmCheckout.optional = true
	return mmCheckout
}

// Expect sets up expected params for Service.Checkout
func (mmCheckout *mServiceMockCheckout) Expect(ctx context.Context, userID int64) *mServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &ServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.paramPtrs != nil {
		mmCheckout.mock.t.Fatalf("ServiceMock.Checkout mock is already set by ExpectParams functions")
	}

	mmCheckout.defaultExpectation.params = &ServiceMockCheckoutParams{ctx, userID}
	for _, e := range mmCheckout.expectations {
		if minimock.Equal(e.params, mmCheckout.defaultExpectation.params) {
			mmCheckout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckout.defaultExpectation.params)
		}
	}

	return mmCheckout
}

// ExpectCtxParam1 sets up expected param ctx for Service.Checkout
func (mmCheckout *mServiceMockCheckout) ExpectCtxParam1(ctx context.Context) *mServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &ServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.params != nil {
		mmCheckout.mock.t.Fatalf("ServiceMock.Checkout mock is already set by Expect")
	}

	if mmCheckout.defaultExpectation.paramPtrs == nil {
		mmCheckout.defaultExpectation.paramPtrs = &ServiceMockCheckoutParamPtrs{}
	}
	mmCheckout.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCheckout
}

// ExpectUserIDParam2 sets up expected param userID for Service.Checkout
func (mmCheckout *mServiceMockCheckout) ExpectUserIDParam2(userID int64) *mServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &ServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.params != nil {
		mmCheckout.mock.t.Fatalf("ServiceMock.Checkout mock is already set by Expect")
	}

	if mmCheckout.defaultExpectation.paramPtrs == nil {
		mmCheckout.defaultExpectation.paramPtrs = &ServiceMockCheckoutParamPtrs{}
	}
	mmCheckout.defaultExpectation.paramPtrs.userID = &userID

	return mmCheckout
}

// Inspect accepts an inspector function that has same arguments as the Service.Checkout
func (mmCheckout *mServiceMockCheckout) Inspect(f func(ctx context.Context, userID int64)) *mServiceMockCheckout {
	if mmCheckout.mock.inspectFuncCheckout != nil {
		mmCheckout.mock.t.Fatalf("Inspect function is already set for ServiceMock.Checkout")
	}

	mmCheckout.mock.inspectFuncCheckout = f

	return mmCheckout
}

// Return sets up results that will be returned by Service.Checkout
func (mmCheckout *mServiceMockCheckout) Return(op1 *model.OrderCart, err error) *ServiceMock {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &ServiceMockCheckoutExpectation{mock: mmCheckout.mock}
	}
	mmCheckout.defaultExpectation.results = &ServiceMockCheckoutResults{op1, err}
	return mmCheckout.mock
}

// Set uses given function f to mock the Service.Checkout method
func (mmCheckout *mServiceMockCheckout) Set(f func(ctx context.Context, userID int64) (op1 *model.OrderCart, err error)) *ServiceMock {
	if mmCheckout.defaultExpectation != nil {
		mmCheckout.mock.t.Fatalf("Default expectation is already set for the Service.Checkout method")
	}

	if len(mmCheckout.expectations) > 0 {
		mmCheckout.mock.t.Fatalf("Some expectations are already set for the Service.Checkout method")
	}

	mmCheckout.mock.funcCheckout = f
	return mmCheckout.mock
}

// When sets expectation for the Service.Checkout which will trigger the result defined by the following
// Then helper
func (mmCheckout *mServiceMockCheckout) When(ctx context.Context, userID int64) *ServiceMockCheckoutExpectation {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("ServiceMock.Checkout mock is already set by Set")
	}

	expectation := &ServiceMockCheckoutExpectation{
		mock:   mmCheckout.mock,
		params: &ServiceMockCheckoutParams{ctx, userID},
	}
	mmCheckout.expectations = append(mmCheckout.expectations, expectation)
	return expectation
}

// Then sets up Service.Checkout return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckoutExpectation) Then(op1 *model.OrderCart, err error) *ServiceMock {
	e.results = &ServiceMockCheckoutResults{op1, err}
	return e.mock
}

// Times sets number of times Service.Checkout should be invoked
func (mmCheckout *mServiceMockCheckout) Times(n uint64) *mServiceMockCheckout {
	if n == 0 {
		mmCheckout.mock.t.Fatalf("Times of ServiceMock.Checkout mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckout.expectedInvocations, n)
	return mmCheckout
}

func (mmCheckout *mServiceMockCheckout) invocationsDone() bool {
	if len(mmCheckout.expectations) == 0 && mmCheckout.defaultExpectation == nil && mmCheckout.mock.funcCheckout == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckout.mock.afterCheckoutCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckout.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Checkout implements cart.Service
func (mmCheckout *ServiceMock) Checkout(ctx context.Context, userID int64) (op1 *model.OrderCart, err error) {
	mm_atomic.AddUint64(&mmCheckout.beforeCheckoutCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckout.afterCheckoutCounter, 1)

	if mmCheckout.inspectFuncCheckout != nil {
		mmCheckout.inspectFuncCheckout(ctx, userID)
	}

	mm_params := ServiceMockCheckoutParams{ctx, userID}

	// Record call args
	mmCheckout.CheckoutMock.mutex.Lock()
	mmCheckout.CheckoutMock.callArgs = append(mmCheckout.CheckoutMock.callArgs, &mm_params)
	mmCheckout.CheckoutMock.mutex.Unlock()

	for _, e := range mmCheckout.CheckoutMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmCheckout.CheckoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckout.CheckoutMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckout.CheckoutMock.defaultExpectation.params
		mm_want_ptrs := mmCheckout.CheckoutMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCheckoutParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckout.t.Errorf("ServiceMock.Checkout got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCheckout.t.Errorf("ServiceMock.Checkout got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckout.t.Errorf("ServiceMock.Checkout got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckout.CheckoutMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckout.t.Fatal("No results are set for the ServiceMock.Checkout")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmCheckout.funcCheckout != nil {
		return mmCheckout.funcCheckout(ctx, userID)
	}
	mmCheckout.t.Fatalf("Unexpected call to ServiceMock.Checkout. %v %v", ctx, userID)
	return
}

// CheckoutAfterCounter returns a count of finished ServiceMock.Checkout invocations
func (mmCheckout *ServiceMock) CheckoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckout.afterCheckoutCounter)
}

// CheckoutBeforeCounter returns a count of ServiceMock.Checkout invocations
func (mmCheckout *ServiceMock) CheckoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckout.beforeCheckoutCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Checkout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckout *mServiceMockCheckout) Calls() []*ServiceMockCheckoutParams {
	mmCheckout.mutex.RLock()

	argCopy := make([]*ServiceMockCheckoutParams, len(mmCheckout.callArgs))
	copy(argCopy, mmCheckout.callArgs)

	mmCheckout.mutex.RUnlock()

	return argCopy
}

// MinimockCheckoutDone returns true if the count of the Checkout invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckoutDone() bool {
	if m.CheckoutMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckoutMock.invocationsDone()
}

// MinimockCheckoutInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckoutInspect() {
	for _, e := range m.CheckoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Checkout with params: %#v", *e.params)
		}
	}

	afterCheckoutCounter := mm_atomic.LoadUint64(&m.afterCheckoutCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckoutMock.defaultExpectation != nil && afterCheckoutCounter < 1 {
		if m.CheckoutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.Checkout")
		} else {
			m.t.Errorf("Expected call to ServiceMock.Checkout with params: %#v", *m.CheckoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckout != nil && afterCheckoutCounter < 1 {
		m.t.Error("Expected call to ServiceMock.Checkout")
	}

	if !m.CheckoutMock.invocationsDone() && afterCheckoutCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Checkout but found %d calls",
			mm_atomic.LoadUint64(&m.CheckoutMock.expectedInvocations), afterCheckoutCounter)
	}
}

type mServiceMockDelCart struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDelCartExpectation
	expectations       []*ServiceMockDelCartExpectation

	callArgs []*ServiceMockDelCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ServiceMockDelCartExpectation specifies expectation struct of the Service.DelCart
type ServiceMockDelCartExpectation struct {
	mock      *ServiceMock
	params    *ServiceMockDelCartParams
	paramPtrs *ServiceMockDelCartParamPtrs
	results   *ServiceMockDelCartResults
	Counter   uint64
}

// ServiceMockDelCartParams contains parameters of the Service.DelCart
type ServiceMockDelCartParams struct {
	ctx    context.Context
	userID int64
}

// ServiceMockDelCartParamPtrs contains pointers to parameters of the Service.DelCart
type ServiceMockDelCartParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// ServiceMockDelCartResults contains results of the Service.DelCart
type ServiceMockDelCartResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelCart *mServiceMockDelCart) Optional() *mServiceMockDelCart {
	mmDelCart.optional = true
	return mmDelCart
}

// Expect sets up expected params for Service.DelCart
func (mmDelCart *mServiceMockDelCart) Expect(ctx context.Context, userID int64) *mServiceMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("ServiceMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &ServiceMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.paramPtrs != nil {
		mmDelCart.mock.t.Fatalf("ServiceMock.DelCart mock is already set by ExpectParams functions")
	}

	mmDelCart.defaultExpectation.params = &ServiceMockDelCartParams{ctx, userID}
	for _, e := range mmDelCart.expectations {
		if minimock.Equal(e.params, mmDelCart.defaultExpectation.params) {
			mmDelCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelCart.defaultExpectation.params)
		}
	}

	return mmDelCart
}

// ExpectCtxParam1 sets up expected param ctx for Service.DelCart
func (mmDelCart *mServiceMockDelCart) ExpectCtxParam1(ctx context.Context) *mServiceMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("ServiceMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &ServiceMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.params != nil {
		mmDelCart.mock.t.Fatalf("ServiceMock.DelCart mock is already set by Expect")
	}

	if mmDelCart.defaultExpectation.paramPtrs == nil {
		mmDelCart.defaultExpectation.paramPtrs = &ServiceMockDelCartParamPtrs{}
	}
	mmDelCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelCart
}

// ExpectUserIDParam2 sets up expected param userID for Service.DelCart
func (mmDelCart *mServiceMockDelCart) ExpectUserIDParam2(userID int64) *mServiceMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("ServiceMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &ServiceMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.params != nil {
		mmDelCart.mock.t.Fatalf("ServiceMock.DelCart mock is already set by Expect")
	}

	if mmDelCart.defaultExpectation.paramPtrs == nil {
		mmDelCart.defaultExpectation.paramPtrs = &ServiceMockDelCartParamPtrs{}
	}
	mmDelCart.defaultExpectation.paramPtrs.userID = &userID

	return mmDelCart
}

// Inspect accepts an inspector function that has same arguments as the Service.DelCart
func (mmDelCart *mServiceMockDelCart) Inspect(f func(ctx context.Context, userID int64)) *mServiceMockDelCart {
	if mmDelCart.mock.inspectFuncDelCart != nil {
		mmDelCart.mock.t.Fatalf("Inspect function is already set for ServiceMock.DelCart")
	}

	mmDelCart.mock.inspectFuncDelCart = f

	return mmDelCart
}

// Return sets up results that will be returned by Service.DelCart
func (mmDelCart *mServiceMockDelCart) Return(err error) *ServiceMock {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("ServiceMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &ServiceMockDelCartExpectation{mock: mmDelCart.mock}
	}
	mmDelCart.defaultExpectation.results = &ServiceMockDelCartResults{err}
	return mmDelCart.mock
}

// Set uses given function f to mock the Service.DelCart method
func (mmDelCart *mServiceMockDelCart) Set(f func(ctx context.Context, userID int64) (err error)) *ServiceMock {
	if mmDelCart.defaultExpectation != nil {
		mmDelCart.mock.t.Fatalf("Default expectation is already set for the Service.DelCart method")
	}

	if len(mmDelCart.expectations) > 0 {
		mmDelCart.mock.t.Fatalf("Some expectations are already set for the Service.DelCart method")
	}

	mmDelCart.mock.funcDelCart = f
	return mmDelCart.mock
}

// When sets expectation for the Service.DelCart which will trigger the result defined by the following
// Then helper
func (mmDelCart *mServiceMockDelCart) When(ctx context.Context, userID int64) *ServiceMockDelCartExpectation {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("ServiceMock.DelCart mock is already set by Set")
	}

	expectation := &ServiceMockDelCartExpectation{
		mock:   mmDelCart.mock,
		params: &ServiceMockDelCartParams{ctx, userID},
	}
	mmDelCart.expectations = append(mmDelCart.expectations, expectation)
	return expectation
}

// Then sets up Service.DelCart return parameters for the expectation previously defined by the When method
func (e *ServiceMockDelCartExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDelCartResults{err}
	return e.mock
}

// Times sets number of times Service.DelCart should be invoked
func (mmDelCart *mServiceMockDelCart) Times(n uint64) *mServiceMockDelCart {
	if n == 0 {
		mmDelCart.mock.t.Fatalf("Times of ServiceMock.DelCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelCart.expectedInvocations, n)
	return mmDelCart
}

func (mmDelCart *mServiceMockDelCart) invocationsDone() bool {
	if len(mmDelCart.expectations) == 0 && mmDelCart.defaultExpectation == nil && mmDelCart.mock.funcDelCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelCart.mock.afterDelCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DelCart implements cart.Service
func (mmDelCart *ServiceMock) DelCart(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmDelCart.beforeDelCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDelCart.afterDelCartCounter, 1)

	if mmDelCart.inspectFuncDelCart != nil {
		mmDelCart.inspectFuncDelCart(ctx, userID)
	}

	mm_params := ServiceMockDelCartParams{ctx, userID}

	// Record call args
	mmDelCart.DelCartMock.mutex.Lock()
	mmDelCart.DelCartMock.callArgs = append(mmDelCart.DelCartMock.callArgs, &mm_params)
	mmDelCart.DelCartMock.mutex.Unlock()

	for _, e := range mmDelCart.DelCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelCart.DelCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelCart.DelCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDelCart.DelCartMock.defaultExpectation.params
		mm_want_ptrs := mmDelCart.DelCartMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDelCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelCart.t.Errorf("ServiceMock.DelCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDelCart.t.Errorf("ServiceMock.DelCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelCart.t.Errorf("ServiceMock.DelCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelCart.DelCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDelCart.t.Fatal("No results are set for the ServiceMock.DelCart")
		}
		return (*mm_results).err
	}
	if mmDelCart.funcDelCart != nil {
		return mmDelCart.funcDelCart(ctx, userID)
	}
	mmDelCart.t.Fatalf("Unexpected call to ServiceMock.DelCart. %v %v", ctx, userID)
	return
}

// DelCartAfterCounter returns a count of finished ServiceMock.DelCart invocations
func (mmDelCart *ServiceMock) DelCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelCart.afterDelCartCounter)
}

// DelCartBeforeCounter returns a count of ServiceMock.DelCart invocations
func (mmDelCart *ServiceMock) DelCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelCart.beforeDelCartCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DelCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelCart *mServiceMockDelCart) Calls() []*ServiceMockDelCartParams {
	mmDelCart.mutex.RLock()

	argCopy := make([]*ServiceMockDelCartParams, len(mmDelCart.callArgs))
	copy(argCopy, mmDelCart.callArgs)

	mmDelCart.mutex.RUnlock()

	return argCopy
}

// MinimockDelCartDone returns true if the count of the DelCart invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDelCartDone() bool {
	if m.DelCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DelCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DelCartMock.invocationsDone()
}

// MinimockDelCartInspect logs each unmet expectation
func (m *ServiceMock) MinimockDelCartInspect() {
	for _, e := range m.DelCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DelCart with params: %#v", *e.params)
		}
	}

	afterDelCartCounter := mm_atomic.LoadUint64(&m.afterDelCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DelCartMock.defaultExpectation != nil && afterDelCartCounter < 1 {
		if m.DelCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.DelCart")
		} else {
			m.t.Errorf("Expected call to ServiceMock.DelCart with params: %#v", *m.DelCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelCart != nil && afterDelCartCounter < 1 {
		m.t.Error("Expected call to ServiceMock.DelCart")
	}

	if !m.DelCartMock.invocationsDone() && afterDelCartCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DelCart but found %d calls",
			mm_atomic.LoadUint64(&m.DelCartMock.expectedInvocations), afterDelCartCounter)
	}
}

type mServiceMockDelItem struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDelItemExpectation
	expectations       []*ServiceMockDelItemExpectation

	callArgs []*ServiceMockDelItemParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ServiceMockDelItemExpectation specifies expectation struct of the Service.DelItem
type ServiceMockDelItemExpectation struct {
	mock      *ServiceMock
	params    *ServiceMockDelItemParams
	paramPtrs *ServiceMockDelItemParamPtrs
	results   *ServiceMockDelItemResults
	Counter   uint64
}

// ServiceMockDelItemParams contains parameters of the Service.DelItem
type ServiceMockDelItemParams struct {
	ctx  context.Context
	item *model.DelItem
}

// ServiceMockDelItemParamPtrs contains pointers to parameters of the Service.DelItem
type ServiceMockDelItemParamPtrs struct {
	ctx  *context.Context
	item **model.DelItem
}

// ServiceMockDelItemResults contains results of the Service.DelItem
type ServiceMockDelItemResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelItem *mServiceMockDelItem) Optional() *mServiceMockDelItem {
	mmDelItem.optional = true
	return mmDelItem
}

// Expect sets up expected params for Service.DelItem
func (mmDelItem *mServiceMockDelItem) Expect(ctx context.Context, item *model.DelItem) *mServiceMockDelItem {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("ServiceMock.DelItem mock is already set by Set")
	}

	if mmDelItem.defaultExpectation == nil {
		mmDelItem.defaultExpectation = &ServiceMockDelItemExpectation{}
	}

	if mmDelItem.defaultExpectation.paramPtrs != nil {
		mmDelItem.mock.t.Fatalf("ServiceMock.DelItem mock is already set by ExpectParams functions")
	}

	mmDelItem.defaultExpectation.params = &ServiceMockDelItemParams{ctx, item}
	for _, e := range mmDelItem.expectations {
		if minimock.Equal(e.params, mmDelItem.defaultExpectation.params) {
			mmDelItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelItem.defaultExpectation.params)
		}
	}

	return mmDelItem
}

// ExpectCtxParam1 sets up expected param ctx for Service.DelItem
func (mmDelItem *mServiceMockDelItem) ExpectCtxParam1(ctx context.Context) *mServiceMockDelItem {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("ServiceMock.DelItem mock is already set by Set")
	}

	if mmDelItem.defaultExpectation == nil {
		mmDelItem.defaultExpectation = &ServiceMockDelItemExpectation{}
	}

	if mmDelItem.defaultExpectation.params != nil {
		mmDelItem.mock.t.Fatalf("ServiceMock.DelItem mock is already set by Expect")
	}

	if mmDelItem.defaultExpectation.paramPtrs == nil {
		mmDelItem.defaultExpectation.paramPtrs = &ServiceMockDelItemParamPtrs{}
	}
	mmDelItem.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelItem
}

// ExpectItemParam2 sets up expected param item for Service.DelItem
func (mmDelItem *mServiceMockDelItem) ExpectItemParam2(item *model.DelItem) *mServiceMockDelItem {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("ServiceMock.DelItem mock is already set by Set")
	}

	if mmDelItem.defaultExpectation == nil {
		mmDelItem.defaultExpectation = &ServiceMockDelItemExpectation{}
	}

	if mmDelItem.defaultExpectation.params != nil {
		mmDelItem.mock.t.Fatalf("ServiceMock.DelItem mock is already set by Expect")
	}

	if mmDelItem.defaultExpectation.paramPtrs == nil {
		mmDelItem.defaultExpectation.paramPtrs = &ServiceMockDelItemParamPtrs{}
	}
	mmDelItem.defaultExpectation.paramPtrs.item = &item

	return mmDelItem
}

// Inspect accepts an inspector function that has same arguments as the Service.DelItem
func (mmDelItem *mServiceMockDelItem) Inspect(f func(ctx context.Context, item *model.DelItem)) *mServiceMockDelItem {
	if mmDelItem.mock.inspectFuncDelItem != nil {
		mmDelItem.mock.t.Fatalf("Inspect function is already set for ServiceMock.DelItem")
	}

	mmDelItem.mock.inspectFuncDelItem = f

	return mmDelItem
}

// Return sets up results that will be returned by Service.DelItem
func (mmDelItem *mServiceMockDelItem) Return(err error) *ServiceMock {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("ServiceMock.DelItem mock is already set by Set")
	}

	if mmDelItem.defaultExpectation == nil {
		mmDelItem.defaultExpectation = &ServiceMockDelItemExpectation{mock: mmDelItem.mock}
	}
	mmDelItem.defaultExpectation.results = &ServiceMockDelItemResults{err}
	return mmDelItem.mock
}

// Set uses given function f to mock the Service.DelItem method
func (mmDelItem *mServiceMockDelItem) Set(f func(ctx context.Context, item *model.DelItem) (err error)) *ServiceMock {
	if mmDelItem.defaultExpectation != nil {
		mmDelItem.mock.t.Fatalf("Default expectation is already set for the Service.DelItem method")
	}

	if len(mmDelItem.expectations) > 0 {
		mmDelItem.mock.t.Fatalf("Some expectations are already set for the Service.DelItem method")
	}

	mmDelItem.mock.funcDelItem = f
	return mmDelItem.mock
}

// When sets expectation for the Service.DelItem which will trigger the result defined by the following
// Then helper
func (mmDelItem *mServiceMockDelItem) When(ctx context.Context, item *model.DelItem) *ServiceMockDelItemExpectation {
	if mmDelItem.mock.funcDelItem != nil {
		mmDelItem.mock.t.Fatalf("ServiceMock.DelItem mock is already set by Set")
	}

	expectation := &ServiceMockDelItemExpectation{
		mock:   mmDelItem.mock,
		params: &ServiceMockDelItemParams{ctx, item},
	}
	mmDelItem.expectations = append(mmDelItem.expectations, expectation)
	return expectation
}

// Then sets up Service.DelItem return parameters for the expectation previously defined by the When method
func (e *ServiceMockDelItemExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDelItemResults{err}
	return e.mock
}

// Times sets number of times Service.DelItem should be invoked
func (mmDelItem *mServiceMockDelItem) Times(n uint64) *mServiceMockDelItem {
	if n == 0 {
		mmDelItem.mock.t.Fatalf("Times of ServiceMock.DelItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelItem.expectedInvocations, n)
	return mmDelItem
}

func (mmDelItem *mServiceMockDelItem) invocationsDone() bool {
	if len(mmDelItem.expectations) == 0 && mmDelItem.defaultExpectation == nil && mmDelItem.mock.funcDelItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelItem.mock.afterDelItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DelItem implements cart.Service
func (mmDelItem *ServiceMock) DelItem(ctx context.Context, item *model.DelItem) (err error) {
	mm_atomic.AddUint64(&mmDelItem.beforeDelItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDelItem.afterDelItemCounter, 1)

	if mmDelItem.inspectFuncDelItem != nil {
		mmDelItem.inspectFuncDelItem(ctx, item)
	}

	mm_params := ServiceMockDelItemParams{ctx, item}

	// Record call args
	mmDelItem.DelItemMock.mutex.Lock()
	mmDelItem.DelItemMock.callArgs = append(mmDelItem.DelItemMock.callArgs, &mm_params)
	mmDelItem.DelItemMock.mutex.Unlock()

	for _, e := range mmDelItem.DelItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelItem.DelItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelItem.DelItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDelItem.DelItemMock.defaultExpectation.params
		mm_want_ptrs := mmDelItem.DelItemMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDelItemParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelItem.t.Errorf("ServiceMock.DelItem got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmDelItem.t.Errorf("ServiceMock.DelItem got unexpected parameter item, want: %#v, got: %#v%s\n", *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelItem.t.Errorf("ServiceMock.DelItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelItem.DelItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDelItem.t.Fatal("No results are set for the ServiceMock.DelItem")
		}
		return (*mm_results).err
	}
	if mmDelItem.funcDelItem != nil {
		return mmDelItem.funcDelItem(ctx, item)
	}
	mmDelItem.t.Fatalf("Unexpected call to ServiceMock.DelItem. %v %v", ctx, item)
	return
}

// DelItemAfterCounter returns a count of finished ServiceMock.DelItem invocations
func (mmDelItem *ServiceMock) DelItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelItem.afterDelItemCounter)
}

// DelItemBeforeCounter returns a count of ServiceMock.DelItem invocations
func (mmDelItem *ServiceMock) DelItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelItem.beforeDelItemCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DelItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelItem *mServiceMockDelItem) Calls() []*ServiceMockDelItemParams {
	mmDelItem.mutex.RLock()

	argCopy := make([]*ServiceMockDelItemParams, len(mmDelItem.callArgs))
	copy(argCopy, mmDelItem.callArgs)

	mmDelItem.mutex.RUnlock()

	return argCopy
}

// MinimockDelItemDone returns true if the count of the DelItem invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDelItemDone() bool {
	if m.DelItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DelItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DelItemMock.invocationsDone()
}

// MinimockDelItemInspect logs each unmet expectation
func (m *ServiceMock) MinimockDelItemInspect() {
	for _, e := range m.DelItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DelItem with params: %#v", *e.params)
		}
	}

	afterDelItemCounter := mm_atomic.LoadUint64(&m.afterDelItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DelItemMock.defaultExpectation != nil && afterDelItemCounter < 1 {
		if m.DelItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.DelItem")
		} else {
			m.t.Errorf("Expected call to ServiceMock.DelItem with params: %#v", *m.DelItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelItem != nil && afterDelItemCounter < 1 {
		m.t.Error("Expected call to ServiceMock.DelItem")
	}

	if !m.DelItemMock.invocationsDone() && afterDelItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DelItem but found %d calls",
			mm_atomic.LoadUint64(&m.DelItemMock.expectedInvocations), afterDelItemCounter)
	}
}

type mServiceMockGetAllUserItems struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetAllUserItemsExpectation
	expectations       []*ServiceMockGetAllUserItemsExpectation

	callArgs []*ServiceMockGetAllUserItemsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ServiceMockGetAllUserItemsExpectation specifies expectation struct of the Service.GetAllUserItems
type ServiceMockGetAllUserItemsExpectation struct {
	mock      *ServiceMock
	params    *ServiceMockGetAllUserItemsParams
	paramPtrs *ServiceMockGetAllUserItemsParamPtrs
	results   *ServiceMockGetAllUserItemsResults
	Counter   uint64
}

// ServiceMockGetAllUserItemsParams contains parameters of the Service.GetAllUserItems
type ServiceMockGetAllUserItemsParams struct {
	ctx    context.Context
	userID int64
}

// ServiceMockGetAllUserItemsParamPtrs contains pointers to parameters of the Service.GetAllUserItems
type ServiceMockGetAllUserItemsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// ServiceMockGetAllUserItemsResults contains results of the Service.GetAllUserItems
type ServiceMockGetAllUserItemsResults struct {
	fp1 *model.FullUserCart
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllUserItems *mServiceMockGetAllUserItems) Optional() *mServiceMockGetAllUserItems {
	mmGetAllUserItems.optional = true
	return mmGetAllUserItems
}

// Expect sets up expected params for Service.GetAllUserItems
func (mmGetAllUserItems *mServiceMockGetAllUserItems) Expect(ctx context.Context, userID int64) *mServiceMockGetAllUserItems {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("ServiceMock.GetAllUserItems mock is already set by Set")
	}

	if mmGetAllUserItems.defaultExpectation == nil {
		mmGetAllUserItems.defaultExpectation = &ServiceMockGetAllUserItemsExpectation{}
	}

	if mmGetAllUserItems.defaultExpectation.paramPtrs != nil {
		mmGetAllUserItems.mock.t.Fatalf("ServiceMock.GetAllUserItems mock is already set by ExpectParams functions")
	}

	mmGetAllUserItems.defaultExpectation.params = &ServiceMockGetAllUserItemsParams{ctx, userID}
	for _, e := range mmGetAllUserItems.expectations {
		if minimock.Equal(e.params, mmGetAllUserItems.defaultExpectation.params) {
			mmGetAllUserItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllUserItems.defaultExpectation.params)
		}
	}

	return mmGetAllUserItems
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetAllUserItems
func (mmGetAllUserItems *mServiceMockGetAllUserItems) ExpectCtxParam1(ctx context.Context) *mServiceMockGetAllUserItems {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("ServiceMock.GetAllUserItems mock is already set by Set")
	}

	if mmGetAllUserItems.defaultExpectation == nil {
		mmGetAllUserItems.defaultExpectation = &ServiceMockGetAllUserItemsExpectation{}
	}

	if mmGetAllUserItems.defaultExpectation.params != nil {
		mmGetAllUserItems.mock.t.Fatalf("ServiceMock.GetAllUserItems mock is already set by Expect")
	}

	if mmGetAllUserItems.defaultExpectation.paramPtrs == nil {
		mmGetAllUserItems.defaultExpectation.paramPtrs = &ServiceMockGetAllUserItemsParamPtrs{}
	}
	mmGetAllUserItems.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAllUserItems
}

// ExpectUserIDParam2 sets up expected param userID for Service.GetAllUserItems
func (mmGetAllUserItems *mServiceMockGetAllUserItems) ExpectUserIDParam2(userID int64) *mServiceMockGetAllUserItems {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("ServiceMock.GetAllUserItems mock is already set by Set")
	}

	if mmGetAllUserItems.defaultExpectation == nil {
		mmGetAllUserItems.defaultExpectation = &ServiceMockGetAllUserItemsExpectation{}
	}

	if mmGetAllUserItems.defaultExpectation.params != nil {
		mmGetAllUserItems.mock.t.Fatalf("ServiceMock.GetAllUserItems mock is already set by Expect")
	}

	if mmGetAllUserItems.defaultExpectation.paramPtrs == nil {
		mmGetAllUserItems.defaultExpectation.paramPtrs = &ServiceMockGetAllUserItemsParamPtrs{}
	}
	mmGetAllUserItems.defaultExpectation.paramPtrs.userID = &userID

	return mmGetAllUserItems
}

// Inspect accepts an inspector function that has same arguments as the Service.GetAllUserItems
func (mmGetAllUserItems *mServiceMockGetAllUserItems) Inspect(f func(ctx context.Context, userID int64)) *mServiceMockGetAllUserItems {
	if mmGetAllUserItems.mock.inspectFuncGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetAllUserItems")
	}

	mmGetAllUserItems.mock.inspectFuncGetAllUserItems = f

	return mmGetAllUserItems
}

// Return sets up results that will be returned by Service.GetAllUserItems
func (mmGetAllUserItems *mServiceMockGetAllUserItems) Return(fp1 *model.FullUserCart, err error) *ServiceMock {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("ServiceMock.GetAllUserItems mock is already set by Set")
	}

	if mmGetAllUserItems.defaultExpectation == nil {
		mmGetAllUserItems.defaultExpectation = &ServiceMockGetAllUserItemsExpectation{mock: mmGetAllUserItems.mock}
	}
	mmGetAllUserItems.defaultExpectation.results = &ServiceMockGetAllUserItemsResults{fp1, err}
	return mmGetAllUserItems.mock
}

// Set uses given function f to mock the Service.GetAllUserItems method
func (mmGetAllUserItems *mServiceMockGetAllUserItems) Set(f func(ctx context.Context, userID int64) (fp1 *model.FullUserCart, err error)) *ServiceMock {
	if mmGetAllUserItems.defaultExpectation != nil {
		mmGetAllUserItems.mock.t.Fatalf("Default expectation is already set for the Service.GetAllUserItems method")
	}

	if len(mmGetAllUserItems.expectations) > 0 {
		mmGetAllUserItems.mock.t.Fatalf("Some expectations are already set for the Service.GetAllUserItems method")
	}

	mmGetAllUserItems.mock.funcGetAllUserItems = f
	return mmGetAllUserItems.mock
}

// When sets expectation for the Service.GetAllUserItems which will trigger the result defined by the following
// Then helper
func (mmGetAllUserItems *mServiceMockGetAllUserItems) When(ctx context.Context, userID int64) *ServiceMockGetAllUserItemsExpectation {
	if mmGetAllUserItems.mock.funcGetAllUserItems != nil {
		mmGetAllUserItems.mock.t.Fatalf("ServiceMock.GetAllUserItems mock is already set by Set")
	}

	expectation := &ServiceMockGetAllUserItemsExpectation{
		mock:   mmGetAllUserItems.mock,
		params: &ServiceMockGetAllUserItemsParams{ctx, userID},
	}
	mmGetAllUserItems.expectations = append(mmGetAllUserItems.expectations, expectation)
	return expectation
}

// Then sets up Service.GetAllUserItems return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetAllUserItemsExpectation) Then(fp1 *model.FullUserCart, err error) *ServiceMock {
	e.results = &ServiceMockGetAllUserItemsResults{fp1, err}
	return e.mock
}

// Times sets number of times Service.GetAllUserItems should be invoked
func (mmGetAllUserItems *mServiceMockGetAllUserItems) Times(n uint64) *mServiceMockGetAllUserItems {
	if n == 0 {
		mmGetAllUserItems.mock.t.Fatalf("Times of ServiceMock.GetAllUserItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllUserItems.expectedInvocations, n)
	return mmGetAllUserItems
}

func (mmGetAllUserItems *mServiceMockGetAllUserItems) invocationsDone() bool {
	if len(mmGetAllUserItems.expectations) == 0 && mmGetAllUserItems.defaultExpectation == nil && mmGetAllUserItems.mock.funcGetAllUserItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllUserItems.mock.afterGetAllUserItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllUserItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllUserItems implements cart.Service
func (mmGetAllUserItems *ServiceMock) GetAllUserItems(ctx context.Context, userID int64) (fp1 *model.FullUserCart, err error) {
	mm_atomic.AddUint64(&mmGetAllUserItems.beforeGetAllUserItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllUserItems.afterGetAllUserItemsCounter, 1)

	if mmGetAllUserItems.inspectFuncGetAllUserItems != nil {
		mmGetAllUserItems.inspectFuncGetAllUserItems(ctx, userID)
	}

	mm_params := ServiceMockGetAllUserItemsParams{ctx, userID}

	// Record call args
	mmGetAllUserItems.GetAllUserItemsMock.mutex.Lock()
	mmGetAllUserItems.GetAllUserItemsMock.callArgs = append(mmGetAllUserItems.GetAllUserItemsMock.callArgs, &mm_params)
	mmGetAllUserItems.GetAllUserItemsMock.mutex.Unlock()

	for _, e := range mmGetAllUserItems.GetAllUserItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fp1, e.results.err
		}
	}

	if mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetAllUserItemsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllUserItems.t.Errorf("ServiceMock.GetAllUserItems got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetAllUserItems.t.Errorf("ServiceMock.GetAllUserItems got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllUserItems.t.Errorf("ServiceMock.GetAllUserItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllUserItems.GetAllUserItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllUserItems.t.Fatal("No results are set for the ServiceMock.GetAllUserItems")
		}
		return (*mm_results).fp1, (*mm_results).err
	}
	if mmGetAllUserItems.funcGetAllUserItems != nil {
		return mmGetAllUserItems.funcGetAllUserItems(ctx, userID)
	}
	mmGetAllUserItems.t.Fatalf("Unexpected call to ServiceMock.GetAllUserItems. %v %v", ctx, userID)
	return
}

// GetAllUserItemsAfterCounter returns a count of finished ServiceMock.GetAllUserItems invocations
func (mmGetAllUserItems *ServiceMock) GetAllUserItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUserItems.afterGetAllUserItemsCounter)
}

// GetAllUserItemsBeforeCounter returns a count of ServiceMock.GetAllUserItems invocations
func (mmGetAllUserItems *ServiceMock) GetAllUserItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUserItems.beforeGetAllUserItemsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetAllUserItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllUserItems *mServiceMockGetAllUserItems) Calls() []*ServiceMockGetAllUserItemsParams {
	mmGetAllUserItems.mutex.RLock()

	argCopy := make([]*ServiceMockGetAllUserItemsParams, len(mmGetAllUserItems.callArgs))
	copy(argCopy, mmGetAllUserItems.callArgs)

	mmGetAllUserItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllUserItemsDone returns true if the count of the GetAllUserItems invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetAllUserItemsDone() bool {
	if m.GetAllUserItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllUserItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllUserItemsMock.invocationsDone()
}

// MinimockGetAllUserItemsInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetAllUserItemsInspect() {
	for _, e := range m.GetAllUserItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetAllUserItems with params: %#v", *e.params)
		}
	}

	afterGetAllUserItemsCounter := mm_atomic.LoadUint64(&m.afterGetAllUserItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllUserItemsMock.defaultExpectation != nil && afterGetAllUserItemsCounter < 1 {
		if m.GetAllUserItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.GetAllUserItems")
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetAllUserItems with params: %#v", *m.GetAllUserItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllUserItems != nil && afterGetAllUserItemsCounter < 1 {
		m.t.Error("Expected call to ServiceMock.GetAllUserItems")
	}

	if !m.GetAllUserItemsMock.invocationsDone() && afterGetAllUserItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetAllUserItems but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllUserItemsMock.expectedInvocations), afterGetAllUserItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockCheckoutInspect()

			m.MinimockDelCartInspect()

			m.MinimockDelItemInspect()

			m.MinimockGetAllUserItemsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockCheckoutDone() &&
		m.MinimockDelCartDone() &&
		m.MinimockDelItemDone() &&
		m.MinimockGetAllUserItemsDone()
}
