// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addOutbox = `-- name: AddOutbox :one
with locked_entity as (
    select status, locked_to
    from "outbox"
    where entity_id = $1::text
      and status = 'locked'
    order by locked_to desc
    LIMIT 1
)
insert into "outbox" (entity_id, "payload", "metadata", "status", locked_to)
    values (
               $1::text,
               $2::text,
               $3::jsonb,
               coalesce((SELECT status FROM locked_entity), 'new'),
               coalesce((SELECT locked_to FROM locked_entity), now())
            )
    returning id
`

type AddOutboxParams struct {
	EntityID string
	Payload  string
	Metadata []byte
}

// При вставке сообщения в outbox гарантируем что если есть заблокированные записи c entity_id, статус lock и время блокировки будет выставлено таким же
func (q *Queries) AddOutbox(ctx context.Context, arg AddOutboxParams) (string, error) {
	row := q.db.QueryRow(ctx, addOutbox, arg.EntityID, arg.Payload, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const outbox = `-- name: Outbox :many
with updated_rows as(
    select id, created_at, updated_at, status, locked_to, entity_id, payload, metadata
    from "outbox"
    where status = $3::outbox_status_type
        or ((status = $1::outbox_status_type or  status = $4::outbox_status_type)
        and locked_to < now() - ($2::text || ' seconds')::interval)
    order by created_at asc
        for update nowait
) update "outbox"
    set status = $1::outbox_status_type,
        locked_to = now() + ($2 ||'seconds')::interval
from updated_rows
    where "outbox".id = updated_rows.id
returning updated_rows.id, updated_rows.created_at, updated_rows.updated_at, updated_rows.status, updated_rows.locked_to, updated_rows.entity_id, updated_rows.payload, updated_rows.metadata
`

type OutboxParams struct {
	StatusLocked OutboxStatusType
	LockedTo     pgtype.Text
	StatusNew    OutboxStatusType
	StatusFailed OutboxStatusType
}

type OutboxRow struct {
	ID        string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
	Status    OutboxStatusType
	LockedTo  pgtype.Timestamp
	EntityID  pgtype.Text
	Payload   pgtype.Text
	Metadata  []byte
}

// При чтении сообщений из outbox, не берем заблокированные записи время блокировки которых не истекло, а так же берем  записи с ошибкой отправки для ретрая
func (q *Queries) Outbox(ctx context.Context, arg OutboxParams) ([]*OutboxRow, error) {
	rows, err := q.db.Query(ctx, outbox,
		arg.StatusLocked,
		arg.LockedTo,
		arg.StatusNew,
		arg.StatusFailed,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*OutboxRow
	for rows.Next() {
		var i OutboxRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.LockedTo,
			&i.EntityID,
			&i.Payload,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setStatusOutbox = `-- name: SetStatusOutbox :exec
update "outbox"
    set status = $1::outbox_status_type,
        updated_at = now()
    where id = $2::varchar
`

type SetStatusOutboxParams struct {
	NewStatus OutboxStatusType
	IDMsg     string
}

func (q *Queries) SetStatusOutbox(ctx context.Context, arg SetStatusOutboxParams) error {
	_, err := q.db.Exec(ctx, setStatusOutbox, arg.NewStatus, arg.IDMsg)
	return err
}
