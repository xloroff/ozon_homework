// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/xloroff/ozon-hw-go/loms/internal/repository/order_store.Storage -o order_storage_mock.go -n OrderStorageMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/xloroff/ozon-hw-go/loms/internal/model"
)

// OrderStorageMock implements orderstore.Storage
type OrderStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrder          func(ctx context.Context, user int64, items model.OrderItems) (i1 int64, err error)
	inspectFuncAddOrder   func(ctx context.Context, user int64, items model.OrderItems)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mOrderStorageMockAddOrder

	funcGetOrder          func(ctx context.Context, orderID int64) (op1 *model.Order, err error)
	inspectFuncGetOrder   func(ctx context.Context, orderID int64)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mOrderStorageMockGetOrder

	funcSetStatus          func(ctx context.Context, orderID int64, status string) (err error)
	inspectFuncSetStatus   func(ctx context.Context, orderID int64, status string)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderStorageMockSetStatus
}

// NewOrderStorageMock returns a mock for orderstore.Storage
func NewOrderStorageMock(t minimock.Tester) *OrderStorageMock {
	m := &OrderStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderMock = mOrderStorageMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*OrderStorageMockAddOrderParams{}

	m.GetOrderMock = mOrderStorageMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*OrderStorageMockGetOrderParams{}

	m.SetStatusMock = mOrderStorageMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderStorageMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderStorageMockAddOrder struct {
	optional           bool
	mock               *OrderStorageMock
	defaultExpectation *OrderStorageMockAddOrderExpectation
	expectations       []*OrderStorageMockAddOrderExpectation

	callArgs []*OrderStorageMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderStorageMockAddOrderExpectation specifies expectation struct of the Storage.AddOrder
type OrderStorageMockAddOrderExpectation struct {
	mock      *OrderStorageMock
	params    *OrderStorageMockAddOrderParams
	paramPtrs *OrderStorageMockAddOrderParamPtrs
	results   *OrderStorageMockAddOrderResults
	Counter   uint64
}

// OrderStorageMockAddOrderParams contains parameters of the Storage.AddOrder
type OrderStorageMockAddOrderParams struct {
	ctx   context.Context
	user  int64
	items model.OrderItems
}

// OrderStorageMockAddOrderParamPtrs contains pointers to parameters of the Storage.AddOrder
type OrderStorageMockAddOrderParamPtrs struct {
	ctx   *context.Context
	user  *int64
	items *model.OrderItems
}

// OrderStorageMockAddOrderResults contains results of the Storage.AddOrder
type OrderStorageMockAddOrderResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mOrderStorageMockAddOrder) Optional() *mOrderStorageMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for Storage.AddOrder
func (mmAddOrder *mOrderStorageMockAddOrder) Expect(ctx context.Context, user int64, items model.OrderItems) *mOrderStorageMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderStorageMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &OrderStorageMockAddOrderParams{ctx, user, items}
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.AddOrder
func (mmAddOrder *mOrderStorageMockAddOrder) ExpectCtxParam1(ctx context.Context) *mOrderStorageMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderStorageMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderStorageMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddOrder
}

// ExpectUserParam2 sets up expected param user for Storage.AddOrder
func (mmAddOrder *mOrderStorageMockAddOrder) ExpectUserParam2(user int64) *mOrderStorageMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderStorageMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderStorageMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.user = &user

	return mmAddOrder
}

// ExpectItemsParam3 sets up expected param items for Storage.AddOrder
func (mmAddOrder *mOrderStorageMockAddOrder) ExpectItemsParam3(items model.OrderItems) *mOrderStorageMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderStorageMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderStorageMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.items = &items

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddOrder
func (mmAddOrder *mOrderStorageMockAddOrder) Inspect(f func(ctx context.Context, user int64, items model.OrderItems)) *mOrderStorageMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for OrderStorageMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by Storage.AddOrder
func (mmAddOrder *mOrderStorageMockAddOrder) Return(i1 int64, err error) *OrderStorageMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderStorageMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &OrderStorageMockAddOrderResults{i1, err}
	return mmAddOrder.mock
}

// Set uses given function f to mock the Storage.AddOrder method
func (mmAddOrder *mOrderStorageMockAddOrder) Set(f func(ctx context.Context, user int64, items model.OrderItems) (i1 int64, err error)) *OrderStorageMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the Storage.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the Storage.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	return mmAddOrder.mock
}

// When sets expectation for the Storage.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mOrderStorageMockAddOrder) When(ctx context.Context, user int64, items model.OrderItems) *OrderStorageMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderStorageMock.AddOrder mock is already set by Set")
	}

	expectation := &OrderStorageMockAddOrderExpectation{
		mock:   mmAddOrder.mock,
		params: &OrderStorageMockAddOrderParams{ctx, user, items},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddOrder return parameters for the expectation previously defined by the When method
func (e *OrderStorageMockAddOrderExpectation) Then(i1 int64, err error) *OrderStorageMock {
	e.results = &OrderStorageMockAddOrderResults{i1, err}
	return e.mock
}

// Times sets number of times Storage.AddOrder should be invoked
func (mmAddOrder *mOrderStorageMockAddOrder) Times(n uint64) *mOrderStorageMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of OrderStorageMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	return mmAddOrder
}

func (mmAddOrder *mOrderStorageMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements orderstore.Storage
func (mmAddOrder *OrderStorageMock) AddOrder(ctx context.Context, user int64, items model.OrderItems) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(ctx, user, items)
	}

	mm_params := OrderStorageMockAddOrderParams{ctx, user, items}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderStorageMockAddOrderParams{ctx, user, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrder.t.Errorf("OrderStorageMock.AddOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmAddOrder.t.Errorf("OrderStorageMock.AddOrder got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmAddOrder.t.Errorf("OrderStorageMock.AddOrder got unexpected parameter items, want: %#v, got: %#v%s\n", *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("OrderStorageMock.AddOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the OrderStorageMock.AddOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(ctx, user, items)
	}
	mmAddOrder.t.Fatalf("Unexpected call to OrderStorageMock.AddOrder. %v %v %v", ctx, user, items)
	return
}

// AddOrderAfterCounter returns a count of finished OrderStorageMock.AddOrder invocations
func (mmAddOrder *OrderStorageMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of OrderStorageMock.AddOrder invocations
func (mmAddOrder *OrderStorageMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderStorageMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mOrderStorageMockAddOrder) Calls() []*OrderStorageMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*OrderStorageMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *OrderStorageMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *OrderStorageMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderStorageMock.AddOrder with params: %#v", *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderStorageMock.AddOrder")
		} else {
			m.t.Errorf("Expected call to OrderStorageMock.AddOrder with params: %#v", *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Error("Expected call to OrderStorageMock.AddOrder")
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageMock.AddOrder but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), afterAddOrderCounter)
	}
}

type mOrderStorageMockGetOrder struct {
	optional           bool
	mock               *OrderStorageMock
	defaultExpectation *OrderStorageMockGetOrderExpectation
	expectations       []*OrderStorageMockGetOrderExpectation

	callArgs []*OrderStorageMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderStorageMockGetOrderExpectation specifies expectation struct of the Storage.GetOrder
type OrderStorageMockGetOrderExpectation struct {
	mock      *OrderStorageMock
	params    *OrderStorageMockGetOrderParams
	paramPtrs *OrderStorageMockGetOrderParamPtrs
	results   *OrderStorageMockGetOrderResults
	Counter   uint64
}

// OrderStorageMockGetOrderParams contains parameters of the Storage.GetOrder
type OrderStorageMockGetOrderParams struct {
	ctx     context.Context
	orderID int64
}

// OrderStorageMockGetOrderParamPtrs contains pointers to parameters of the Storage.GetOrder
type OrderStorageMockGetOrderParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrderStorageMockGetOrderResults contains results of the Storage.GetOrder
type OrderStorageMockGetOrderResults struct {
	op1 *model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mOrderStorageMockGetOrder) Optional() *mOrderStorageMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for Storage.GetOrder
func (mmGetOrder *mOrderStorageMockGetOrder) Expect(ctx context.Context, orderID int64) *mOrderStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderStorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &OrderStorageMockGetOrderParams{ctx, orderID}
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetOrder
func (mmGetOrder *mOrderStorageMockGetOrder) ExpectCtxParam1(ctx context.Context) *mOrderStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderStorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &OrderStorageMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for Storage.GetOrder
func (mmGetOrder *mOrderStorageMockGetOrder) ExpectOrderIDParam2(orderID int64) *mOrderStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderStorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &OrderStorageMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.orderID = &orderID

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetOrder
func (mmGetOrder *mOrderStorageMockGetOrder) Inspect(f func(ctx context.Context, orderID int64)) *mOrderStorageMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for OrderStorageMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by Storage.GetOrder
func (mmGetOrder *mOrderStorageMockGetOrder) Return(op1 *model.Order, err error) *OrderStorageMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderStorageMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &OrderStorageMockGetOrderResults{op1, err}
	return mmGetOrder.mock
}

// Set uses given function f to mock the Storage.GetOrder method
func (mmGetOrder *mOrderStorageMockGetOrder) Set(f func(ctx context.Context, orderID int64) (op1 *model.Order, err error)) *OrderStorageMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the Storage.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the Storage.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	return mmGetOrder.mock
}

// When sets expectation for the Storage.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mOrderStorageMockGetOrder) When(ctx context.Context, orderID int64) *OrderStorageMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageMock.GetOrder mock is already set by Set")
	}

	expectation := &OrderStorageMockGetOrderExpectation{
		mock:   mmGetOrder.mock,
		params: &OrderStorageMockGetOrderParams{ctx, orderID},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetOrder return parameters for the expectation previously defined by the When method
func (e *OrderStorageMockGetOrderExpectation) Then(op1 *model.Order, err error) *OrderStorageMock {
	e.results = &OrderStorageMockGetOrderResults{op1, err}
	return e.mock
}

// Times sets number of times Storage.GetOrder should be invoked
func (mmGetOrder *mOrderStorageMockGetOrder) Times(n uint64) *mOrderStorageMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of OrderStorageMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	return mmGetOrder
}

func (mmGetOrder *mOrderStorageMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements orderstore.Storage
func (mmGetOrder *OrderStorageMock) GetOrder(ctx context.Context, orderID int64) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, orderID)
	}

	mm_params := OrderStorageMockGetOrderParams{ctx, orderID}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderStorageMockGetOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("OrderStorageMock.GetOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrder.t.Errorf("OrderStorageMock.GetOrder got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("OrderStorageMock.GetOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the OrderStorageMock.GetOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, orderID)
	}
	mmGetOrder.t.Fatalf("Unexpected call to OrderStorageMock.GetOrder. %v %v", ctx, orderID)
	return
}

// GetOrderAfterCounter returns a count of finished OrderStorageMock.GetOrder invocations
func (mmGetOrder *OrderStorageMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of OrderStorageMock.GetOrder invocations
func (mmGetOrder *OrderStorageMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderStorageMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mOrderStorageMockGetOrder) Calls() []*OrderStorageMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*OrderStorageMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *OrderStorageMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *OrderStorageMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderStorageMock.GetOrder with params: %#v", *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderStorageMock.GetOrder")
		} else {
			m.t.Errorf("Expected call to OrderStorageMock.GetOrder with params: %#v", *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Error("Expected call to OrderStorageMock.GetOrder")
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageMock.GetOrder but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), afterGetOrderCounter)
	}
}

type mOrderStorageMockSetStatus struct {
	optional           bool
	mock               *OrderStorageMock
	defaultExpectation *OrderStorageMockSetStatusExpectation
	expectations       []*OrderStorageMockSetStatusExpectation

	callArgs []*OrderStorageMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderStorageMockSetStatusExpectation specifies expectation struct of the Storage.SetStatus
type OrderStorageMockSetStatusExpectation struct {
	mock      *OrderStorageMock
	params    *OrderStorageMockSetStatusParams
	paramPtrs *OrderStorageMockSetStatusParamPtrs
	results   *OrderStorageMockSetStatusResults
	Counter   uint64
}

// OrderStorageMockSetStatusParams contains parameters of the Storage.SetStatus
type OrderStorageMockSetStatusParams struct {
	ctx     context.Context
	orderID int64
	status  string
}

// OrderStorageMockSetStatusParamPtrs contains pointers to parameters of the Storage.SetStatus
type OrderStorageMockSetStatusParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *string
}

// OrderStorageMockSetStatusResults contains results of the Storage.SetStatus
type OrderStorageMockSetStatusResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderStorageMockSetStatus) Optional() *mOrderStorageMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for Storage.SetStatus
func (mmSetStatus *mOrderStorageMockSetStatus) Expect(ctx context.Context, orderID int64, status string) *mOrderStorageMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderStorageMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderStorageMockSetStatusParams{ctx, orderID, status}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for Storage.SetStatus
func (mmSetStatus *mOrderStorageMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderStorageMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderStorageMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderStorageMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetStatus
}

// ExpectOrderIDParam2 sets up expected param orderID for Storage.SetStatus
func (mmSetStatus *mOrderStorageMockSetStatus) ExpectOrderIDParam2(orderID int64) *mOrderStorageMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderStorageMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderStorageMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.orderID = &orderID

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for Storage.SetStatus
func (mmSetStatus *mOrderStorageMockSetStatus) ExpectStatusParam3(status string) *mOrderStorageMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderStorageMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderStorageMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the Storage.SetStatus
func (mmSetStatus *mOrderStorageMockSetStatus) Inspect(f func(ctx context.Context, orderID int64, status string)) *mOrderStorageMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderStorageMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by Storage.SetStatus
func (mmSetStatus *mOrderStorageMockSetStatus) Return(err error) *OrderStorageMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderStorageMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderStorageMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the Storage.SetStatus method
func (mmSetStatus *mOrderStorageMockSetStatus) Set(f func(ctx context.Context, orderID int64, status string) (err error)) *OrderStorageMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the Storage.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the Storage.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the Storage.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderStorageMockSetStatus) When(ctx context.Context, orderID int64, status string) *OrderStorageMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderStorageMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderStorageMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrderStorageMockSetStatusParams{ctx, orderID, status},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up Storage.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderStorageMockSetStatusExpectation) Then(err error) *OrderStorageMock {
	e.results = &OrderStorageMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times Storage.SetStatus should be invoked
func (mmSetStatus *mOrderStorageMockSetStatus) Times(n uint64) *mOrderStorageMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderStorageMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	return mmSetStatus
}

func (mmSetStatus *mOrderStorageMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements orderstore.Storage
func (mmSetStatus *OrderStorageMock) SetStatus(ctx context.Context, orderID int64, status string) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, orderID, status)
	}

	mm_params := OrderStorageMockSetStatusParams{ctx, orderID, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderStorageMockSetStatusParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderStorageMock.SetStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatus.t.Errorf("OrderStorageMock.SetStatus got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("OrderStorageMock.SetStatus got unexpected parameter status, want: %#v, got: %#v%s\n", *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderStorageMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderStorageMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, orderID, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderStorageMock.SetStatus. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusAfterCounter returns a count of finished OrderStorageMock.SetStatus invocations
func (mmSetStatus *OrderStorageMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderStorageMock.SetStatus invocations
func (mmSetStatus *OrderStorageMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderStorageMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderStorageMockSetStatus) Calls() []*OrderStorageMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderStorageMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderStorageMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderStorageMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderStorageMock.SetStatus with params: %#v", *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderStorageMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrderStorageMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Error("Expected call to OrderStorageMock.SetStatus")
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageMock.SetStatus but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderInspect()

			m.MinimockGetOrderInspect()

			m.MinimockSetStatusInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockSetStatusDone()
}
