// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/xloroff/ozon-hw-go/loms/internal/repository/stock_store.Storage -o stock_storage_mock.go -n StockStorageMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/xloroff/ozon-hw-go/loms/internal/model"
)

// StockStorageMock implements stockstore.Storage
type StockStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddReserve          func(ctx context.Context, items model.AllNeedReserve) (err error)
	inspectFuncAddReserve   func(ctx context.Context, items model.AllNeedReserve)
	afterAddReserveCounter  uint64
	beforeAddReserveCounter uint64
	AddReserveMock          mStockStorageMockAddReserve

	funcCancelReserve          func(ctx context.Context, items model.AllNeedReserve) (err error)
	inspectFuncCancelReserve   func(ctx context.Context, items model.AllNeedReserve)
	afterCancelReserveCounter  uint64
	beforeCancelReserveCounter uint64
	CancelReserveMock          mStockStorageMockCancelReserve

	funcDelItemFromReserve          func(ctx context.Context, items model.AllNeedReserve) (err error)
	inspectFuncDelItemFromReserve   func(ctx context.Context, items model.AllNeedReserve)
	afterDelItemFromReserveCounter  uint64
	beforeDelItemFromReserveCounter uint64
	DelItemFromReserveMock          mStockStorageMockDelItemFromReserve

	funcGetAvailableForReserve          func(ctx context.Context, sku int64) (u1 uint16, err error)
	inspectFuncGetAvailableForReserve   func(ctx context.Context, sku int64)
	afterGetAvailableForReserveCounter  uint64
	beforeGetAvailableForReserveCounter uint64
	GetAvailableForReserveMock          mStockStorageMockGetAvailableForReserve
}

// NewStockStorageMock returns a mock for stockstore.Storage
func NewStockStorageMock(t minimock.Tester) *StockStorageMock {
	m := &StockStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddReserveMock = mStockStorageMockAddReserve{mock: m}
	m.AddReserveMock.callArgs = []*StockStorageMockAddReserveParams{}

	m.CancelReserveMock = mStockStorageMockCancelReserve{mock: m}
	m.CancelReserveMock.callArgs = []*StockStorageMockCancelReserveParams{}

	m.DelItemFromReserveMock = mStockStorageMockDelItemFromReserve{mock: m}
	m.DelItemFromReserveMock.callArgs = []*StockStorageMockDelItemFromReserveParams{}

	m.GetAvailableForReserveMock = mStockStorageMockGetAvailableForReserve{mock: m}
	m.GetAvailableForReserveMock.callArgs = []*StockStorageMockGetAvailableForReserveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockStorageMockAddReserve struct {
	optional           bool
	mock               *StockStorageMock
	defaultExpectation *StockStorageMockAddReserveExpectation
	expectations       []*StockStorageMockAddReserveExpectation

	callArgs []*StockStorageMockAddReserveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockStorageMockAddReserveExpectation specifies expectation struct of the Storage.AddReserve
type StockStorageMockAddReserveExpectation struct {
	mock      *StockStorageMock
	params    *StockStorageMockAddReserveParams
	paramPtrs *StockStorageMockAddReserveParamPtrs
	results   *StockStorageMockAddReserveResults
	Counter   uint64
}

// StockStorageMockAddReserveParams contains parameters of the Storage.AddReserve
type StockStorageMockAddReserveParams struct {
	ctx   context.Context
	items model.AllNeedReserve
}

// StockStorageMockAddReserveParamPtrs contains pointers to parameters of the Storage.AddReserve
type StockStorageMockAddReserveParamPtrs struct {
	ctx   *context.Context
	items *model.AllNeedReserve
}

// StockStorageMockAddReserveResults contains results of the Storage.AddReserve
type StockStorageMockAddReserveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReserve *mStockStorageMockAddReserve) Optional() *mStockStorageMockAddReserve {
	mmAddReserve.optional = true
	return mmAddReserve
}

// Expect sets up expected params for Storage.AddReserve
func (mmAddReserve *mStockStorageMockAddReserve) Expect(ctx context.Context, items model.AllNeedReserve) *mStockStorageMockAddReserve {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockStorageMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockStorageMockAddReserveExpectation{}
	}

	if mmAddReserve.defaultExpectation.paramPtrs != nil {
		mmAddReserve.mock.t.Fatalf("StockStorageMock.AddReserve mock is already set by ExpectParams functions")
	}

	mmAddReserve.defaultExpectation.params = &StockStorageMockAddReserveParams{ctx, items}
	for _, e := range mmAddReserve.expectations {
		if minimock.Equal(e.params, mmAddReserve.defaultExpectation.params) {
			mmAddReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReserve.defaultExpectation.params)
		}
	}

	return mmAddReserve
}

// ExpectCtxParam1 sets up expected param ctx for Storage.AddReserve
func (mmAddReserve *mStockStorageMockAddReserve) ExpectCtxParam1(ctx context.Context) *mStockStorageMockAddReserve {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockStorageMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockStorageMockAddReserveExpectation{}
	}

	if mmAddReserve.defaultExpectation.params != nil {
		mmAddReserve.mock.t.Fatalf("StockStorageMock.AddReserve mock is already set by Expect")
	}

	if mmAddReserve.defaultExpectation.paramPtrs == nil {
		mmAddReserve.defaultExpectation.paramPtrs = &StockStorageMockAddReserveParamPtrs{}
	}
	mmAddReserve.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddReserve
}

// ExpectItemsParam2 sets up expected param items for Storage.AddReserve
func (mmAddReserve *mStockStorageMockAddReserve) ExpectItemsParam2(items model.AllNeedReserve) *mStockStorageMockAddReserve {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockStorageMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockStorageMockAddReserveExpectation{}
	}

	if mmAddReserve.defaultExpectation.params != nil {
		mmAddReserve.mock.t.Fatalf("StockStorageMock.AddReserve mock is already set by Expect")
	}

	if mmAddReserve.defaultExpectation.paramPtrs == nil {
		mmAddReserve.defaultExpectation.paramPtrs = &StockStorageMockAddReserveParamPtrs{}
	}
	mmAddReserve.defaultExpectation.paramPtrs.items = &items

	return mmAddReserve
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddReserve
func (mmAddReserve *mStockStorageMockAddReserve) Inspect(f func(ctx context.Context, items model.AllNeedReserve)) *mStockStorageMockAddReserve {
	if mmAddReserve.mock.inspectFuncAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("Inspect function is already set for StockStorageMock.AddReserve")
	}

	mmAddReserve.mock.inspectFuncAddReserve = f

	return mmAddReserve
}

// Return sets up results that will be returned by Storage.AddReserve
func (mmAddReserve *mStockStorageMockAddReserve) Return(err error) *StockStorageMock {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockStorageMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockStorageMockAddReserveExpectation{mock: mmAddReserve.mock}
	}
	mmAddReserve.defaultExpectation.results = &StockStorageMockAddReserveResults{err}
	return mmAddReserve.mock
}

// Set uses given function f to mock the Storage.AddReserve method
func (mmAddReserve *mStockStorageMockAddReserve) Set(f func(ctx context.Context, items model.AllNeedReserve) (err error)) *StockStorageMock {
	if mmAddReserve.defaultExpectation != nil {
		mmAddReserve.mock.t.Fatalf("Default expectation is already set for the Storage.AddReserve method")
	}

	if len(mmAddReserve.expectations) > 0 {
		mmAddReserve.mock.t.Fatalf("Some expectations are already set for the Storage.AddReserve method")
	}

	mmAddReserve.mock.funcAddReserve = f
	return mmAddReserve.mock
}

// When sets expectation for the Storage.AddReserve which will trigger the result defined by the following
// Then helper
func (mmAddReserve *mStockStorageMockAddReserve) When(ctx context.Context, items model.AllNeedReserve) *StockStorageMockAddReserveExpectation {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockStorageMock.AddReserve mock is already set by Set")
	}

	expectation := &StockStorageMockAddReserveExpectation{
		mock:   mmAddReserve.mock,
		params: &StockStorageMockAddReserveParams{ctx, items},
	}
	mmAddReserve.expectations = append(mmAddReserve.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddReserve return parameters for the expectation previously defined by the When method
func (e *StockStorageMockAddReserveExpectation) Then(err error) *StockStorageMock {
	e.results = &StockStorageMockAddReserveResults{err}
	return e.mock
}

// Times sets number of times Storage.AddReserve should be invoked
func (mmAddReserve *mStockStorageMockAddReserve) Times(n uint64) *mStockStorageMockAddReserve {
	if n == 0 {
		mmAddReserve.mock.t.Fatalf("Times of StockStorageMock.AddReserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddReserve.expectedInvocations, n)
	return mmAddReserve
}

func (mmAddReserve *mStockStorageMockAddReserve) invocationsDone() bool {
	if len(mmAddReserve.expectations) == 0 && mmAddReserve.defaultExpectation == nil && mmAddReserve.mock.funcAddReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddReserve.mock.afterAddReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddReserve implements stockstore.Storage
func (mmAddReserve *StockStorageMock) AddReserve(ctx context.Context, items model.AllNeedReserve) (err error) {
	mm_atomic.AddUint64(&mmAddReserve.beforeAddReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmAddReserve.afterAddReserveCounter, 1)

	if mmAddReserve.inspectFuncAddReserve != nil {
		mmAddReserve.inspectFuncAddReserve(ctx, items)
	}

	mm_params := StockStorageMockAddReserveParams{ctx, items}

	// Record call args
	mmAddReserve.AddReserveMock.mutex.Lock()
	mmAddReserve.AddReserveMock.callArgs = append(mmAddReserve.AddReserveMock.callArgs, &mm_params)
	mmAddReserve.AddReserveMock.mutex.Unlock()

	for _, e := range mmAddReserve.AddReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddReserve.AddReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddReserve.AddReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmAddReserve.AddReserveMock.defaultExpectation.params
		mm_want_ptrs := mmAddReserve.AddReserveMock.defaultExpectation.paramPtrs

		mm_got := StockStorageMockAddReserveParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddReserve.t.Errorf("StockStorageMock.AddReserve got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmAddReserve.t.Errorf("StockStorageMock.AddReserve got unexpected parameter items, want: %#v, got: %#v%s\n", *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddReserve.t.Errorf("StockStorageMock.AddReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddReserve.AddReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmAddReserve.t.Fatal("No results are set for the StockStorageMock.AddReserve")
		}
		return (*mm_results).err
	}
	if mmAddReserve.funcAddReserve != nil {
		return mmAddReserve.funcAddReserve(ctx, items)
	}
	mmAddReserve.t.Fatalf("Unexpected call to StockStorageMock.AddReserve. %v %v", ctx, items)
	return
}

// AddReserveAfterCounter returns a count of finished StockStorageMock.AddReserve invocations
func (mmAddReserve *StockStorageMock) AddReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReserve.afterAddReserveCounter)
}

// AddReserveBeforeCounter returns a count of StockStorageMock.AddReserve invocations
func (mmAddReserve *StockStorageMock) AddReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReserve.beforeAddReserveCounter)
}

// Calls returns a list of arguments used in each call to StockStorageMock.AddReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReserve *mStockStorageMockAddReserve) Calls() []*StockStorageMockAddReserveParams {
	mmAddReserve.mutex.RLock()

	argCopy := make([]*StockStorageMockAddReserveParams, len(mmAddReserve.callArgs))
	copy(argCopy, mmAddReserve.callArgs)

	mmAddReserve.mutex.RUnlock()

	return argCopy
}

// MinimockAddReserveDone returns true if the count of the AddReserve invocations corresponds
// the number of defined expectations
func (m *StockStorageMock) MinimockAddReserveDone() bool {
	if m.AddReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddReserveMock.invocationsDone()
}

// MinimockAddReserveInspect logs each unmet expectation
func (m *StockStorageMock) MinimockAddReserveInspect() {
	for _, e := range m.AddReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockStorageMock.AddReserve with params: %#v", *e.params)
		}
	}

	afterAddReserveCounter := mm_atomic.LoadUint64(&m.afterAddReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddReserveMock.defaultExpectation != nil && afterAddReserveCounter < 1 {
		if m.AddReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockStorageMock.AddReserve")
		} else {
			m.t.Errorf("Expected call to StockStorageMock.AddReserve with params: %#v", *m.AddReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddReserve != nil && afterAddReserveCounter < 1 {
		m.t.Error("Expected call to StockStorageMock.AddReserve")
	}

	if !m.AddReserveMock.invocationsDone() && afterAddReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockStorageMock.AddReserve but found %d calls",
			mm_atomic.LoadUint64(&m.AddReserveMock.expectedInvocations), afterAddReserveCounter)
	}
}

type mStockStorageMockCancelReserve struct {
	optional           bool
	mock               *StockStorageMock
	defaultExpectation *StockStorageMockCancelReserveExpectation
	expectations       []*StockStorageMockCancelReserveExpectation

	callArgs []*StockStorageMockCancelReserveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockStorageMockCancelReserveExpectation specifies expectation struct of the Storage.CancelReserve
type StockStorageMockCancelReserveExpectation struct {
	mock      *StockStorageMock
	params    *StockStorageMockCancelReserveParams
	paramPtrs *StockStorageMockCancelReserveParamPtrs
	results   *StockStorageMockCancelReserveResults
	Counter   uint64
}

// StockStorageMockCancelReserveParams contains parameters of the Storage.CancelReserve
type StockStorageMockCancelReserveParams struct {
	ctx   context.Context
	items model.AllNeedReserve
}

// StockStorageMockCancelReserveParamPtrs contains pointers to parameters of the Storage.CancelReserve
type StockStorageMockCancelReserveParamPtrs struct {
	ctx   *context.Context
	items *model.AllNeedReserve
}

// StockStorageMockCancelReserveResults contains results of the Storage.CancelReserve
type StockStorageMockCancelReserveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelReserve *mStockStorageMockCancelReserve) Optional() *mStockStorageMockCancelReserve {
	mmCancelReserve.optional = true
	return mmCancelReserve
}

// Expect sets up expected params for Storage.CancelReserve
func (mmCancelReserve *mStockStorageMockCancelReserve) Expect(ctx context.Context, items model.AllNeedReserve) *mStockStorageMockCancelReserve {
	if mmCancelReserve.mock.funcCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("StockStorageMock.CancelReserve mock is already set by Set")
	}

	if mmCancelReserve.defaultExpectation == nil {
		mmCancelReserve.defaultExpectation = &StockStorageMockCancelReserveExpectation{}
	}

	if mmCancelReserve.defaultExpectation.paramPtrs != nil {
		mmCancelReserve.mock.t.Fatalf("StockStorageMock.CancelReserve mock is already set by ExpectParams functions")
	}

	mmCancelReserve.defaultExpectation.params = &StockStorageMockCancelReserveParams{ctx, items}
	for _, e := range mmCancelReserve.expectations {
		if minimock.Equal(e.params, mmCancelReserve.defaultExpectation.params) {
			mmCancelReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelReserve.defaultExpectation.params)
		}
	}

	return mmCancelReserve
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CancelReserve
func (mmCancelReserve *mStockStorageMockCancelReserve) ExpectCtxParam1(ctx context.Context) *mStockStorageMockCancelReserve {
	if mmCancelReserve.mock.funcCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("StockStorageMock.CancelReserve mock is already set by Set")
	}

	if mmCancelReserve.defaultExpectation == nil {
		mmCancelReserve.defaultExpectation = &StockStorageMockCancelReserveExpectation{}
	}

	if mmCancelReserve.defaultExpectation.params != nil {
		mmCancelReserve.mock.t.Fatalf("StockStorageMock.CancelReserve mock is already set by Expect")
	}

	if mmCancelReserve.defaultExpectation.paramPtrs == nil {
		mmCancelReserve.defaultExpectation.paramPtrs = &StockStorageMockCancelReserveParamPtrs{}
	}
	mmCancelReserve.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCancelReserve
}

// ExpectItemsParam2 sets up expected param items for Storage.CancelReserve
func (mmCancelReserve *mStockStorageMockCancelReserve) ExpectItemsParam2(items model.AllNeedReserve) *mStockStorageMockCancelReserve {
	if mmCancelReserve.mock.funcCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("StockStorageMock.CancelReserve mock is already set by Set")
	}

	if mmCancelReserve.defaultExpectation == nil {
		mmCancelReserve.defaultExpectation = &StockStorageMockCancelReserveExpectation{}
	}

	if mmCancelReserve.defaultExpectation.params != nil {
		mmCancelReserve.mock.t.Fatalf("StockStorageMock.CancelReserve mock is already set by Expect")
	}

	if mmCancelReserve.defaultExpectation.paramPtrs == nil {
		mmCancelReserve.defaultExpectation.paramPtrs = &StockStorageMockCancelReserveParamPtrs{}
	}
	mmCancelReserve.defaultExpectation.paramPtrs.items = &items

	return mmCancelReserve
}

// Inspect accepts an inspector function that has same arguments as the Storage.CancelReserve
func (mmCancelReserve *mStockStorageMockCancelReserve) Inspect(f func(ctx context.Context, items model.AllNeedReserve)) *mStockStorageMockCancelReserve {
	if mmCancelReserve.mock.inspectFuncCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("Inspect function is already set for StockStorageMock.CancelReserve")
	}

	mmCancelReserve.mock.inspectFuncCancelReserve = f

	return mmCancelReserve
}

// Return sets up results that will be returned by Storage.CancelReserve
func (mmCancelReserve *mStockStorageMockCancelReserve) Return(err error) *StockStorageMock {
	if mmCancelReserve.mock.funcCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("StockStorageMock.CancelReserve mock is already set by Set")
	}

	if mmCancelReserve.defaultExpectation == nil {
		mmCancelReserve.defaultExpectation = &StockStorageMockCancelReserveExpectation{mock: mmCancelReserve.mock}
	}
	mmCancelReserve.defaultExpectation.results = &StockStorageMockCancelReserveResults{err}
	return mmCancelReserve.mock
}

// Set uses given function f to mock the Storage.CancelReserve method
func (mmCancelReserve *mStockStorageMockCancelReserve) Set(f func(ctx context.Context, items model.AllNeedReserve) (err error)) *StockStorageMock {
	if mmCancelReserve.defaultExpectation != nil {
		mmCancelReserve.mock.t.Fatalf("Default expectation is already set for the Storage.CancelReserve method")
	}

	if len(mmCancelReserve.expectations) > 0 {
		mmCancelReserve.mock.t.Fatalf("Some expectations are already set for the Storage.CancelReserve method")
	}

	mmCancelReserve.mock.funcCancelReserve = f
	return mmCancelReserve.mock
}

// When sets expectation for the Storage.CancelReserve which will trigger the result defined by the following
// Then helper
func (mmCancelReserve *mStockStorageMockCancelReserve) When(ctx context.Context, items model.AllNeedReserve) *StockStorageMockCancelReserveExpectation {
	if mmCancelReserve.mock.funcCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("StockStorageMock.CancelReserve mock is already set by Set")
	}

	expectation := &StockStorageMockCancelReserveExpectation{
		mock:   mmCancelReserve.mock,
		params: &StockStorageMockCancelReserveParams{ctx, items},
	}
	mmCancelReserve.expectations = append(mmCancelReserve.expectations, expectation)
	return expectation
}

// Then sets up Storage.CancelReserve return parameters for the expectation previously defined by the When method
func (e *StockStorageMockCancelReserveExpectation) Then(err error) *StockStorageMock {
	e.results = &StockStorageMockCancelReserveResults{err}
	return e.mock
}

// Times sets number of times Storage.CancelReserve should be invoked
func (mmCancelReserve *mStockStorageMockCancelReserve) Times(n uint64) *mStockStorageMockCancelReserve {
	if n == 0 {
		mmCancelReserve.mock.t.Fatalf("Times of StockStorageMock.CancelReserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelReserve.expectedInvocations, n)
	return mmCancelReserve
}

func (mmCancelReserve *mStockStorageMockCancelReserve) invocationsDone() bool {
	if len(mmCancelReserve.expectations) == 0 && mmCancelReserve.defaultExpectation == nil && mmCancelReserve.mock.funcCancelReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelReserve.mock.afterCancelReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelReserve implements stockstore.Storage
func (mmCancelReserve *StockStorageMock) CancelReserve(ctx context.Context, items model.AllNeedReserve) (err error) {
	mm_atomic.AddUint64(&mmCancelReserve.beforeCancelReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelReserve.afterCancelReserveCounter, 1)

	if mmCancelReserve.inspectFuncCancelReserve != nil {
		mmCancelReserve.inspectFuncCancelReserve(ctx, items)
	}

	mm_params := StockStorageMockCancelReserveParams{ctx, items}

	// Record call args
	mmCancelReserve.CancelReserveMock.mutex.Lock()
	mmCancelReserve.CancelReserveMock.callArgs = append(mmCancelReserve.CancelReserveMock.callArgs, &mm_params)
	mmCancelReserve.CancelReserveMock.mutex.Unlock()

	for _, e := range mmCancelReserve.CancelReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelReserve.CancelReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelReserve.CancelReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelReserve.CancelReserveMock.defaultExpectation.params
		mm_want_ptrs := mmCancelReserve.CancelReserveMock.defaultExpectation.paramPtrs

		mm_got := StockStorageMockCancelReserveParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCancelReserve.t.Errorf("StockStorageMock.CancelReserve got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmCancelReserve.t.Errorf("StockStorageMock.CancelReserve got unexpected parameter items, want: %#v, got: %#v%s\n", *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelReserve.t.Errorf("StockStorageMock.CancelReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelReserve.CancelReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelReserve.t.Fatal("No results are set for the StockStorageMock.CancelReserve")
		}
		return (*mm_results).err
	}
	if mmCancelReserve.funcCancelReserve != nil {
		return mmCancelReserve.funcCancelReserve(ctx, items)
	}
	mmCancelReserve.t.Fatalf("Unexpected call to StockStorageMock.CancelReserve. %v %v", ctx, items)
	return
}

// CancelReserveAfterCounter returns a count of finished StockStorageMock.CancelReserve invocations
func (mmCancelReserve *StockStorageMock) CancelReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReserve.afterCancelReserveCounter)
}

// CancelReserveBeforeCounter returns a count of StockStorageMock.CancelReserve invocations
func (mmCancelReserve *StockStorageMock) CancelReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReserve.beforeCancelReserveCounter)
}

// Calls returns a list of arguments used in each call to StockStorageMock.CancelReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelReserve *mStockStorageMockCancelReserve) Calls() []*StockStorageMockCancelReserveParams {
	mmCancelReserve.mutex.RLock()

	argCopy := make([]*StockStorageMockCancelReserveParams, len(mmCancelReserve.callArgs))
	copy(argCopy, mmCancelReserve.callArgs)

	mmCancelReserve.mutex.RUnlock()

	return argCopy
}

// MinimockCancelReserveDone returns true if the count of the CancelReserve invocations corresponds
// the number of defined expectations
func (m *StockStorageMock) MinimockCancelReserveDone() bool {
	if m.CancelReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelReserveMock.invocationsDone()
}

// MinimockCancelReserveInspect logs each unmet expectation
func (m *StockStorageMock) MinimockCancelReserveInspect() {
	for _, e := range m.CancelReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockStorageMock.CancelReserve with params: %#v", *e.params)
		}
	}

	afterCancelReserveCounter := mm_atomic.LoadUint64(&m.afterCancelReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelReserveMock.defaultExpectation != nil && afterCancelReserveCounter < 1 {
		if m.CancelReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockStorageMock.CancelReserve")
		} else {
			m.t.Errorf("Expected call to StockStorageMock.CancelReserve with params: %#v", *m.CancelReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelReserve != nil && afterCancelReserveCounter < 1 {
		m.t.Error("Expected call to StockStorageMock.CancelReserve")
	}

	if !m.CancelReserveMock.invocationsDone() && afterCancelReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockStorageMock.CancelReserve but found %d calls",
			mm_atomic.LoadUint64(&m.CancelReserveMock.expectedInvocations), afterCancelReserveCounter)
	}
}

type mStockStorageMockDelItemFromReserve struct {
	optional           bool
	mock               *StockStorageMock
	defaultExpectation *StockStorageMockDelItemFromReserveExpectation
	expectations       []*StockStorageMockDelItemFromReserveExpectation

	callArgs []*StockStorageMockDelItemFromReserveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockStorageMockDelItemFromReserveExpectation specifies expectation struct of the Storage.DelItemFromReserve
type StockStorageMockDelItemFromReserveExpectation struct {
	mock      *StockStorageMock
	params    *StockStorageMockDelItemFromReserveParams
	paramPtrs *StockStorageMockDelItemFromReserveParamPtrs
	results   *StockStorageMockDelItemFromReserveResults
	Counter   uint64
}

// StockStorageMockDelItemFromReserveParams contains parameters of the Storage.DelItemFromReserve
type StockStorageMockDelItemFromReserveParams struct {
	ctx   context.Context
	items model.AllNeedReserve
}

// StockStorageMockDelItemFromReserveParamPtrs contains pointers to parameters of the Storage.DelItemFromReserve
type StockStorageMockDelItemFromReserveParamPtrs struct {
	ctx   *context.Context
	items *model.AllNeedReserve
}

// StockStorageMockDelItemFromReserveResults contains results of the Storage.DelItemFromReserve
type StockStorageMockDelItemFromReserveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) Optional() *mStockStorageMockDelItemFromReserve {
	mmDelItemFromReserve.optional = true
	return mmDelItemFromReserve
}

// Expect sets up expected params for Storage.DelItemFromReserve
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) Expect(ctx context.Context, items model.AllNeedReserve) *mStockStorageMockDelItemFromReserve {
	if mmDelItemFromReserve.mock.funcDelItemFromReserve != nil {
		mmDelItemFromReserve.mock.t.Fatalf("StockStorageMock.DelItemFromReserve mock is already set by Set")
	}

	if mmDelItemFromReserve.defaultExpectation == nil {
		mmDelItemFromReserve.defaultExpectation = &StockStorageMockDelItemFromReserveExpectation{}
	}

	if mmDelItemFromReserve.defaultExpectation.paramPtrs != nil {
		mmDelItemFromReserve.mock.t.Fatalf("StockStorageMock.DelItemFromReserve mock is already set by ExpectParams functions")
	}

	mmDelItemFromReserve.defaultExpectation.params = &StockStorageMockDelItemFromReserveParams{ctx, items}
	for _, e := range mmDelItemFromReserve.expectations {
		if minimock.Equal(e.params, mmDelItemFromReserve.defaultExpectation.params) {
			mmDelItemFromReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelItemFromReserve.defaultExpectation.params)
		}
	}

	return mmDelItemFromReserve
}

// ExpectCtxParam1 sets up expected param ctx for Storage.DelItemFromReserve
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) ExpectCtxParam1(ctx context.Context) *mStockStorageMockDelItemFromReserve {
	if mmDelItemFromReserve.mock.funcDelItemFromReserve != nil {
		mmDelItemFromReserve.mock.t.Fatalf("StockStorageMock.DelItemFromReserve mock is already set by Set")
	}

	if mmDelItemFromReserve.defaultExpectation == nil {
		mmDelItemFromReserve.defaultExpectation = &StockStorageMockDelItemFromReserveExpectation{}
	}

	if mmDelItemFromReserve.defaultExpectation.params != nil {
		mmDelItemFromReserve.mock.t.Fatalf("StockStorageMock.DelItemFromReserve mock is already set by Expect")
	}

	if mmDelItemFromReserve.defaultExpectation.paramPtrs == nil {
		mmDelItemFromReserve.defaultExpectation.paramPtrs = &StockStorageMockDelItemFromReserveParamPtrs{}
	}
	mmDelItemFromReserve.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelItemFromReserve
}

// ExpectItemsParam2 sets up expected param items for Storage.DelItemFromReserve
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) ExpectItemsParam2(items model.AllNeedReserve) *mStockStorageMockDelItemFromReserve {
	if mmDelItemFromReserve.mock.funcDelItemFromReserve != nil {
		mmDelItemFromReserve.mock.t.Fatalf("StockStorageMock.DelItemFromReserve mock is already set by Set")
	}

	if mmDelItemFromReserve.defaultExpectation == nil {
		mmDelItemFromReserve.defaultExpectation = &StockStorageMockDelItemFromReserveExpectation{}
	}

	if mmDelItemFromReserve.defaultExpectation.params != nil {
		mmDelItemFromReserve.mock.t.Fatalf("StockStorageMock.DelItemFromReserve mock is already set by Expect")
	}

	if mmDelItemFromReserve.defaultExpectation.paramPtrs == nil {
		mmDelItemFromReserve.defaultExpectation.paramPtrs = &StockStorageMockDelItemFromReserveParamPtrs{}
	}
	mmDelItemFromReserve.defaultExpectation.paramPtrs.items = &items

	return mmDelItemFromReserve
}

// Inspect accepts an inspector function that has same arguments as the Storage.DelItemFromReserve
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) Inspect(f func(ctx context.Context, items model.AllNeedReserve)) *mStockStorageMockDelItemFromReserve {
	if mmDelItemFromReserve.mock.inspectFuncDelItemFromReserve != nil {
		mmDelItemFromReserve.mock.t.Fatalf("Inspect function is already set for StockStorageMock.DelItemFromReserve")
	}

	mmDelItemFromReserve.mock.inspectFuncDelItemFromReserve = f

	return mmDelItemFromReserve
}

// Return sets up results that will be returned by Storage.DelItemFromReserve
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) Return(err error) *StockStorageMock {
	if mmDelItemFromReserve.mock.funcDelItemFromReserve != nil {
		mmDelItemFromReserve.mock.t.Fatalf("StockStorageMock.DelItemFromReserve mock is already set by Set")
	}

	if mmDelItemFromReserve.defaultExpectation == nil {
		mmDelItemFromReserve.defaultExpectation = &StockStorageMockDelItemFromReserveExpectation{mock: mmDelItemFromReserve.mock}
	}
	mmDelItemFromReserve.defaultExpectation.results = &StockStorageMockDelItemFromReserveResults{err}
	return mmDelItemFromReserve.mock
}

// Set uses given function f to mock the Storage.DelItemFromReserve method
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) Set(f func(ctx context.Context, items model.AllNeedReserve) (err error)) *StockStorageMock {
	if mmDelItemFromReserve.defaultExpectation != nil {
		mmDelItemFromReserve.mock.t.Fatalf("Default expectation is already set for the Storage.DelItemFromReserve method")
	}

	if len(mmDelItemFromReserve.expectations) > 0 {
		mmDelItemFromReserve.mock.t.Fatalf("Some expectations are already set for the Storage.DelItemFromReserve method")
	}

	mmDelItemFromReserve.mock.funcDelItemFromReserve = f
	return mmDelItemFromReserve.mock
}

// When sets expectation for the Storage.DelItemFromReserve which will trigger the result defined by the following
// Then helper
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) When(ctx context.Context, items model.AllNeedReserve) *StockStorageMockDelItemFromReserveExpectation {
	if mmDelItemFromReserve.mock.funcDelItemFromReserve != nil {
		mmDelItemFromReserve.mock.t.Fatalf("StockStorageMock.DelItemFromReserve mock is already set by Set")
	}

	expectation := &StockStorageMockDelItemFromReserveExpectation{
		mock:   mmDelItemFromReserve.mock,
		params: &StockStorageMockDelItemFromReserveParams{ctx, items},
	}
	mmDelItemFromReserve.expectations = append(mmDelItemFromReserve.expectations, expectation)
	return expectation
}

// Then sets up Storage.DelItemFromReserve return parameters for the expectation previously defined by the When method
func (e *StockStorageMockDelItemFromReserveExpectation) Then(err error) *StockStorageMock {
	e.results = &StockStorageMockDelItemFromReserveResults{err}
	return e.mock
}

// Times sets number of times Storage.DelItemFromReserve should be invoked
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) Times(n uint64) *mStockStorageMockDelItemFromReserve {
	if n == 0 {
		mmDelItemFromReserve.mock.t.Fatalf("Times of StockStorageMock.DelItemFromReserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelItemFromReserve.expectedInvocations, n)
	return mmDelItemFromReserve
}

func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) invocationsDone() bool {
	if len(mmDelItemFromReserve.expectations) == 0 && mmDelItemFromReserve.defaultExpectation == nil && mmDelItemFromReserve.mock.funcDelItemFromReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelItemFromReserve.mock.afterDelItemFromReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelItemFromReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DelItemFromReserve implements stockstore.Storage
func (mmDelItemFromReserve *StockStorageMock) DelItemFromReserve(ctx context.Context, items model.AllNeedReserve) (err error) {
	mm_atomic.AddUint64(&mmDelItemFromReserve.beforeDelItemFromReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmDelItemFromReserve.afterDelItemFromReserveCounter, 1)

	if mmDelItemFromReserve.inspectFuncDelItemFromReserve != nil {
		mmDelItemFromReserve.inspectFuncDelItemFromReserve(ctx, items)
	}

	mm_params := StockStorageMockDelItemFromReserveParams{ctx, items}

	// Record call args
	mmDelItemFromReserve.DelItemFromReserveMock.mutex.Lock()
	mmDelItemFromReserve.DelItemFromReserveMock.callArgs = append(mmDelItemFromReserve.DelItemFromReserveMock.callArgs, &mm_params)
	mmDelItemFromReserve.DelItemFromReserveMock.mutex.Unlock()

	for _, e := range mmDelItemFromReserve.DelItemFromReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelItemFromReserve.DelItemFromReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelItemFromReserve.DelItemFromReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmDelItemFromReserve.DelItemFromReserveMock.defaultExpectation.params
		mm_want_ptrs := mmDelItemFromReserve.DelItemFromReserveMock.defaultExpectation.paramPtrs

		mm_got := StockStorageMockDelItemFromReserveParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelItemFromReserve.t.Errorf("StockStorageMock.DelItemFromReserve got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmDelItemFromReserve.t.Errorf("StockStorageMock.DelItemFromReserve got unexpected parameter items, want: %#v, got: %#v%s\n", *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelItemFromReserve.t.Errorf("StockStorageMock.DelItemFromReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelItemFromReserve.DelItemFromReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmDelItemFromReserve.t.Fatal("No results are set for the StockStorageMock.DelItemFromReserve")
		}
		return (*mm_results).err
	}
	if mmDelItemFromReserve.funcDelItemFromReserve != nil {
		return mmDelItemFromReserve.funcDelItemFromReserve(ctx, items)
	}
	mmDelItemFromReserve.t.Fatalf("Unexpected call to StockStorageMock.DelItemFromReserve. %v %v", ctx, items)
	return
}

// DelItemFromReserveAfterCounter returns a count of finished StockStorageMock.DelItemFromReserve invocations
func (mmDelItemFromReserve *StockStorageMock) DelItemFromReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelItemFromReserve.afterDelItemFromReserveCounter)
}

// DelItemFromReserveBeforeCounter returns a count of StockStorageMock.DelItemFromReserve invocations
func (mmDelItemFromReserve *StockStorageMock) DelItemFromReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelItemFromReserve.beforeDelItemFromReserveCounter)
}

// Calls returns a list of arguments used in each call to StockStorageMock.DelItemFromReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelItemFromReserve *mStockStorageMockDelItemFromReserve) Calls() []*StockStorageMockDelItemFromReserveParams {
	mmDelItemFromReserve.mutex.RLock()

	argCopy := make([]*StockStorageMockDelItemFromReserveParams, len(mmDelItemFromReserve.callArgs))
	copy(argCopy, mmDelItemFromReserve.callArgs)

	mmDelItemFromReserve.mutex.RUnlock()

	return argCopy
}

// MinimockDelItemFromReserveDone returns true if the count of the DelItemFromReserve invocations corresponds
// the number of defined expectations
func (m *StockStorageMock) MinimockDelItemFromReserveDone() bool {
	if m.DelItemFromReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DelItemFromReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DelItemFromReserveMock.invocationsDone()
}

// MinimockDelItemFromReserveInspect logs each unmet expectation
func (m *StockStorageMock) MinimockDelItemFromReserveInspect() {
	for _, e := range m.DelItemFromReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockStorageMock.DelItemFromReserve with params: %#v", *e.params)
		}
	}

	afterDelItemFromReserveCounter := mm_atomic.LoadUint64(&m.afterDelItemFromReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DelItemFromReserveMock.defaultExpectation != nil && afterDelItemFromReserveCounter < 1 {
		if m.DelItemFromReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockStorageMock.DelItemFromReserve")
		} else {
			m.t.Errorf("Expected call to StockStorageMock.DelItemFromReserve with params: %#v", *m.DelItemFromReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelItemFromReserve != nil && afterDelItemFromReserveCounter < 1 {
		m.t.Error("Expected call to StockStorageMock.DelItemFromReserve")
	}

	if !m.DelItemFromReserveMock.invocationsDone() && afterDelItemFromReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockStorageMock.DelItemFromReserve but found %d calls",
			mm_atomic.LoadUint64(&m.DelItemFromReserveMock.expectedInvocations), afterDelItemFromReserveCounter)
	}
}

type mStockStorageMockGetAvailableForReserve struct {
	optional           bool
	mock               *StockStorageMock
	defaultExpectation *StockStorageMockGetAvailableForReserveExpectation
	expectations       []*StockStorageMockGetAvailableForReserveExpectation

	callArgs []*StockStorageMockGetAvailableForReserveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockStorageMockGetAvailableForReserveExpectation specifies expectation struct of the Storage.GetAvailableForReserve
type StockStorageMockGetAvailableForReserveExpectation struct {
	mock      *StockStorageMock
	params    *StockStorageMockGetAvailableForReserveParams
	paramPtrs *StockStorageMockGetAvailableForReserveParamPtrs
	results   *StockStorageMockGetAvailableForReserveResults
	Counter   uint64
}

// StockStorageMockGetAvailableForReserveParams contains parameters of the Storage.GetAvailableForReserve
type StockStorageMockGetAvailableForReserveParams struct {
	ctx context.Context
	sku int64
}

// StockStorageMockGetAvailableForReserveParamPtrs contains pointers to parameters of the Storage.GetAvailableForReserve
type StockStorageMockGetAvailableForReserveParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// StockStorageMockGetAvailableForReserveResults contains results of the Storage.GetAvailableForReserve
type StockStorageMockGetAvailableForReserveResults struct {
	u1  uint16
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) Optional() *mStockStorageMockGetAvailableForReserve {
	mmGetAvailableForReserve.optional = true
	return mmGetAvailableForReserve
}

// Expect sets up expected params for Storage.GetAvailableForReserve
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) Expect(ctx context.Context, sku int64) *mStockStorageMockGetAvailableForReserve {
	if mmGetAvailableForReserve.mock.funcGetAvailableForReserve != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("StockStorageMock.GetAvailableForReserve mock is already set by Set")
	}

	if mmGetAvailableForReserve.defaultExpectation == nil {
		mmGetAvailableForReserve.defaultExpectation = &StockStorageMockGetAvailableForReserveExpectation{}
	}

	if mmGetAvailableForReserve.defaultExpectation.paramPtrs != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("StockStorageMock.GetAvailableForReserve mock is already set by ExpectParams functions")
	}

	mmGetAvailableForReserve.defaultExpectation.params = &StockStorageMockGetAvailableForReserveParams{ctx, sku}
	for _, e := range mmGetAvailableForReserve.expectations {
		if minimock.Equal(e.params, mmGetAvailableForReserve.defaultExpectation.params) {
			mmGetAvailableForReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAvailableForReserve.defaultExpectation.params)
		}
	}

	return mmGetAvailableForReserve
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetAvailableForReserve
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) ExpectCtxParam1(ctx context.Context) *mStockStorageMockGetAvailableForReserve {
	if mmGetAvailableForReserve.mock.funcGetAvailableForReserve != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("StockStorageMock.GetAvailableForReserve mock is already set by Set")
	}

	if mmGetAvailableForReserve.defaultExpectation == nil {
		mmGetAvailableForReserve.defaultExpectation = &StockStorageMockGetAvailableForReserveExpectation{}
	}

	if mmGetAvailableForReserve.defaultExpectation.params != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("StockStorageMock.GetAvailableForReserve mock is already set by Expect")
	}

	if mmGetAvailableForReserve.defaultExpectation.paramPtrs == nil {
		mmGetAvailableForReserve.defaultExpectation.paramPtrs = &StockStorageMockGetAvailableForReserveParamPtrs{}
	}
	mmGetAvailableForReserve.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAvailableForReserve
}

// ExpectSkuParam2 sets up expected param sku for Storage.GetAvailableForReserve
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) ExpectSkuParam2(sku int64) *mStockStorageMockGetAvailableForReserve {
	if mmGetAvailableForReserve.mock.funcGetAvailableForReserve != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("StockStorageMock.GetAvailableForReserve mock is already set by Set")
	}

	if mmGetAvailableForReserve.defaultExpectation == nil {
		mmGetAvailableForReserve.defaultExpectation = &StockStorageMockGetAvailableForReserveExpectation{}
	}

	if mmGetAvailableForReserve.defaultExpectation.params != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("StockStorageMock.GetAvailableForReserve mock is already set by Expect")
	}

	if mmGetAvailableForReserve.defaultExpectation.paramPtrs == nil {
		mmGetAvailableForReserve.defaultExpectation.paramPtrs = &StockStorageMockGetAvailableForReserveParamPtrs{}
	}
	mmGetAvailableForReserve.defaultExpectation.paramPtrs.sku = &sku

	return mmGetAvailableForReserve
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetAvailableForReserve
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) Inspect(f func(ctx context.Context, sku int64)) *mStockStorageMockGetAvailableForReserve {
	if mmGetAvailableForReserve.mock.inspectFuncGetAvailableForReserve != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("Inspect function is already set for StockStorageMock.GetAvailableForReserve")
	}

	mmGetAvailableForReserve.mock.inspectFuncGetAvailableForReserve = f

	return mmGetAvailableForReserve
}

// Return sets up results that will be returned by Storage.GetAvailableForReserve
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) Return(u1 uint16, err error) *StockStorageMock {
	if mmGetAvailableForReserve.mock.funcGetAvailableForReserve != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("StockStorageMock.GetAvailableForReserve mock is already set by Set")
	}

	if mmGetAvailableForReserve.defaultExpectation == nil {
		mmGetAvailableForReserve.defaultExpectation = &StockStorageMockGetAvailableForReserveExpectation{mock: mmGetAvailableForReserve.mock}
	}
	mmGetAvailableForReserve.defaultExpectation.results = &StockStorageMockGetAvailableForReserveResults{u1, err}
	return mmGetAvailableForReserve.mock
}

// Set uses given function f to mock the Storage.GetAvailableForReserve method
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) Set(f func(ctx context.Context, sku int64) (u1 uint16, err error)) *StockStorageMock {
	if mmGetAvailableForReserve.defaultExpectation != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("Default expectation is already set for the Storage.GetAvailableForReserve method")
	}

	if len(mmGetAvailableForReserve.expectations) > 0 {
		mmGetAvailableForReserve.mock.t.Fatalf("Some expectations are already set for the Storage.GetAvailableForReserve method")
	}

	mmGetAvailableForReserve.mock.funcGetAvailableForReserve = f
	return mmGetAvailableForReserve.mock
}

// When sets expectation for the Storage.GetAvailableForReserve which will trigger the result defined by the following
// Then helper
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) When(ctx context.Context, sku int64) *StockStorageMockGetAvailableForReserveExpectation {
	if mmGetAvailableForReserve.mock.funcGetAvailableForReserve != nil {
		mmGetAvailableForReserve.mock.t.Fatalf("StockStorageMock.GetAvailableForReserve mock is already set by Set")
	}

	expectation := &StockStorageMockGetAvailableForReserveExpectation{
		mock:   mmGetAvailableForReserve.mock,
		params: &StockStorageMockGetAvailableForReserveParams{ctx, sku},
	}
	mmGetAvailableForReserve.expectations = append(mmGetAvailableForReserve.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetAvailableForReserve return parameters for the expectation previously defined by the When method
func (e *StockStorageMockGetAvailableForReserveExpectation) Then(u1 uint16, err error) *StockStorageMock {
	e.results = &StockStorageMockGetAvailableForReserveResults{u1, err}
	return e.mock
}

// Times sets number of times Storage.GetAvailableForReserve should be invoked
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) Times(n uint64) *mStockStorageMockGetAvailableForReserve {
	if n == 0 {
		mmGetAvailableForReserve.mock.t.Fatalf("Times of StockStorageMock.GetAvailableForReserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAvailableForReserve.expectedInvocations, n)
	return mmGetAvailableForReserve
}

func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) invocationsDone() bool {
	if len(mmGetAvailableForReserve.expectations) == 0 && mmGetAvailableForReserve.defaultExpectation == nil && mmGetAvailableForReserve.mock.funcGetAvailableForReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAvailableForReserve.mock.afterGetAvailableForReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAvailableForReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAvailableForReserve implements stockstore.Storage
func (mmGetAvailableForReserve *StockStorageMock) GetAvailableForReserve(ctx context.Context, sku int64) (u1 uint16, err error) {
	mm_atomic.AddUint64(&mmGetAvailableForReserve.beforeGetAvailableForReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAvailableForReserve.afterGetAvailableForReserveCounter, 1)

	if mmGetAvailableForReserve.inspectFuncGetAvailableForReserve != nil {
		mmGetAvailableForReserve.inspectFuncGetAvailableForReserve(ctx, sku)
	}

	mm_params := StockStorageMockGetAvailableForReserveParams{ctx, sku}

	// Record call args
	mmGetAvailableForReserve.GetAvailableForReserveMock.mutex.Lock()
	mmGetAvailableForReserve.GetAvailableForReserveMock.callArgs = append(mmGetAvailableForReserve.GetAvailableForReserveMock.callArgs, &mm_params)
	mmGetAvailableForReserve.GetAvailableForReserveMock.mutex.Unlock()

	for _, e := range mmGetAvailableForReserve.GetAvailableForReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetAvailableForReserve.GetAvailableForReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAvailableForReserve.GetAvailableForReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAvailableForReserve.GetAvailableForReserveMock.defaultExpectation.params
		mm_want_ptrs := mmGetAvailableForReserve.GetAvailableForReserveMock.defaultExpectation.paramPtrs

		mm_got := StockStorageMockGetAvailableForReserveParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAvailableForReserve.t.Errorf("StockStorageMock.GetAvailableForReserve got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetAvailableForReserve.t.Errorf("StockStorageMock.GetAvailableForReserve got unexpected parameter sku, want: %#v, got: %#v%s\n", *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAvailableForReserve.t.Errorf("StockStorageMock.GetAvailableForReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAvailableForReserve.GetAvailableForReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAvailableForReserve.t.Fatal("No results are set for the StockStorageMock.GetAvailableForReserve")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetAvailableForReserve.funcGetAvailableForReserve != nil {
		return mmGetAvailableForReserve.funcGetAvailableForReserve(ctx, sku)
	}
	mmGetAvailableForReserve.t.Fatalf("Unexpected call to StockStorageMock.GetAvailableForReserve. %v %v", ctx, sku)
	return
}

// GetAvailableForReserveAfterCounter returns a count of finished StockStorageMock.GetAvailableForReserve invocations
func (mmGetAvailableForReserve *StockStorageMock) GetAvailableForReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableForReserve.afterGetAvailableForReserveCounter)
}

// GetAvailableForReserveBeforeCounter returns a count of StockStorageMock.GetAvailableForReserve invocations
func (mmGetAvailableForReserve *StockStorageMock) GetAvailableForReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableForReserve.beforeGetAvailableForReserveCounter)
}

// Calls returns a list of arguments used in each call to StockStorageMock.GetAvailableForReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAvailableForReserve *mStockStorageMockGetAvailableForReserve) Calls() []*StockStorageMockGetAvailableForReserveParams {
	mmGetAvailableForReserve.mutex.RLock()

	argCopy := make([]*StockStorageMockGetAvailableForReserveParams, len(mmGetAvailableForReserve.callArgs))
	copy(argCopy, mmGetAvailableForReserve.callArgs)

	mmGetAvailableForReserve.mutex.RUnlock()

	return argCopy
}

// MinimockGetAvailableForReserveDone returns true if the count of the GetAvailableForReserve invocations corresponds
// the number of defined expectations
func (m *StockStorageMock) MinimockGetAvailableForReserveDone() bool {
	if m.GetAvailableForReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAvailableForReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAvailableForReserveMock.invocationsDone()
}

// MinimockGetAvailableForReserveInspect logs each unmet expectation
func (m *StockStorageMock) MinimockGetAvailableForReserveInspect() {
	for _, e := range m.GetAvailableForReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockStorageMock.GetAvailableForReserve with params: %#v", *e.params)
		}
	}

	afterGetAvailableForReserveCounter := mm_atomic.LoadUint64(&m.afterGetAvailableForReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAvailableForReserveMock.defaultExpectation != nil && afterGetAvailableForReserveCounter < 1 {
		if m.GetAvailableForReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockStorageMock.GetAvailableForReserve")
		} else {
			m.t.Errorf("Expected call to StockStorageMock.GetAvailableForReserve with params: %#v", *m.GetAvailableForReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAvailableForReserve != nil && afterGetAvailableForReserveCounter < 1 {
		m.t.Error("Expected call to StockStorageMock.GetAvailableForReserve")
	}

	if !m.GetAvailableForReserveMock.invocationsDone() && afterGetAvailableForReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockStorageMock.GetAvailableForReserve but found %d calls",
			mm_atomic.LoadUint64(&m.GetAvailableForReserveMock.expectedInvocations), afterGetAvailableForReserveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddReserveInspect()

			m.MinimockCancelReserveInspect()

			m.MinimockDelItemFromReserveInspect()

			m.MinimockGetAvailableForReserveInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddReserveDone() &&
		m.MinimockCancelReserveDone() &&
		m.MinimockDelItemFromReserveDone() &&
		m.MinimockGetAvailableForReserveDone()
}
